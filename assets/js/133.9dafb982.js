(window.webpackJsonp=window.webpackJsonp||[]).push([[133],{330:function(_,t,v){"use strict";v.r(t);var a=v(0),s=Object(a.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存"}},[_._v("#")]),_._v(" 内存")]),_._v(" "),v("p",[_._v("我们通常所说的内存特指的是物理内存（内存条）。")]),_._v(" "),v("h2",{attrs:{id:"一、演变"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、演变"}},[_._v("#")]),_._v(" 一、演变")]),_._v(" "),v("p",[_._v("（1）在DOS时代，同时只能运行一个进程。")]),_._v(" "),v("p",[_._v("（2）在Windows9X时代，随着内存越来越大，这时可以同时执行多个进程了。但会出现"),v("strong",[_._v("内存不够用")]),_._v("的情况，内存撑爆，导致进程闪退。进程之间的内存可以互相打扰（访问），不能够保证"),v("strong",[_._v("程序和数据的安全")]),_._v("。")]),_._v(" "),v("p",[_._v("（3）为了解决上述两个问题，诞生了"),v("strong",[_._v("现代的内存管理系统。")])]),_._v(" "),v("h2",{attrs:{id:"二、内存管理系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、内存管理系统"}},[_._v("#")]),_._v(" 二、内存管理系统")]),_._v(" "),v("h4",{attrs:{id:"_1、虚拟内存地址"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、虚拟内存地址"}},[_._v("#")]),_._v(" 1、虚拟内存地址")]),_._v(" "),v("p",[_._v("进程启动时，操作系统会为每一个进程分配一块独立的虚拟内存空间，保证了进程之间的独立和安全。在32位操作系统中，虚拟内存空间大小是4GB。在64位操作系统中，虚拟内存空间大小是128T。")]),_._v(" "),v("p",[_._v("虚拟内存空间又被分为两部分，一部分是用户空间，另一部分是内核空间，保障了进程不能随意访问内核的内存空间，确保操作系统的安全。")]),_._v(" "),v("p",[_._v("进程在用户态时只能访问用户空间的内存。只有进入内核态，才能访问内核空间的内存。虽然每个进程都有一个内核空间，都这些内核空间对应的都是同一块物理内存，访问的是同一块资源。")]),_._v(" "),v("h4",{attrs:{id:"_2、内存映射"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、内存映射"}},[_._v("#")]),_._v(" 2、内存映射")]),_._v(" "),v("p",[_._v("进程的虚拟内存空间总归使用的还是物理内存。通过内存映射，记录虚拟内存地址与物理内存地址的映射关系。内核为每个进程都维护了一张"),v("strong",[_._v("页表")]),_._v("，页表实际存储在CPU的内存管理单元MMU中，处理器可以直接通过硬件找到具体的物理内存地址。")]),_._v(" "),v("p",[_._v("MMU起初以4KB的块来管理内存，导致整个的页表项会特别多。在32位操作系统中，4GB的内存就需要映射100多万个页表。")]),_._v(" "),v("p",[_._v("为了解决这一问题，Linux系统提供了两种机制，"),v("strong",[_._v("多级页表")]),_._v("和"),v("strong",[_._v("大页")]),_._v("（不展开）。")]),_._v(" "),v("h4",{attrs:{id:"_3、内存分配"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、内存分配"}},[_._v("#")]),_._v(" 3、内存分配")]),_._v(" "),v("p",[_._v("进程的虚拟内存空间并不会直接分配到物理内存。当需要时，才会被分配真正的物理内存。")]),_._v(" "),v("p",[_._v("比如进程想要加载磁盘的文件到虚拟内存空间中，就需要通过页表查询映射。此时内存还没有被分配，因此找不到对应的映射关系，就会触发操作系统的**缺页异常。**就会进入内核空间分配物理内存，并更新进程页表，最后再返回用户空间，恢复进程的进行。")]),_._v(" "),v("h4",{attrs:{id:"_4、访问数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、访问数据"}},[_._v("#")]),_._v(" 4、访问数据")]),_._v(" "),v("p",[_._v("当CPU要获取物理内存中的数据时，需要访问两次内存。第一次是根据虚拟内存地址在MMU中找到真实的物理内存地址，第二次根据物理内存地址找到对应的数据。")]),_._v(" "),v("p",[_._v("为了提高在页表项中寻找真实物理内存地址的性能，引入了TLB，"),v("strong",[_._v("TLB是MMU中页表的高速缓存")]),_._v("。")]),_._v(" "),v("p",[_._v("由于进程的虚拟地址空间的独立的，TLB的访问速度又比MMU快得多。可以通过减少进程的上下文切换（"),v("strong",[_._v("机器上少跑进程呗")]),_._v("），从而减少TLB的刷新次数，就可以提高TLB的告诉缓存的利用率，进而提高CPU的内存访问性能。也就是说。")]),_._v(" "),v("p",[_._v("当物理内存不足时，会根据LRU算法将内存上的数据换出到磁盘上，当再读取时从磁盘上换入到内存中，将"),v("strong",[_._v("页表的映射关系由虚拟内存地址指向磁盘地址")]),_._v("。使用到交换空间时，就会影响到性能。")])])}),[],!1,null,null,null);t.default=s.exports}}]);