(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{210:function(n,t,r){"use strict";r.r(t);var e=r(0),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"字符串"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#字符串"}},[n._v("#")]),n._v(" 字符串")]),n._v(" "),r("p",[n._v('字符串使用 "+" 拼接时，只要存在一个引用，那么生成的对象就在堆中 。\n字符串使用 concat 拼接时，生成的对象都在堆中。')]),n._v(" "),r("p",[n._v("public class StringTest {")]),n._v(" "),r("pre",[r("code",[n._v("public static void main(String[] args) {\n")])]),n._v(" "),r("p",[n._v('//        // 只会在堆中创建String对象\n//        String a = new String("123");\n//        // 字符串常量池如果有该字符串，则直接返回字符串常量池相应的地址\n// 字符串常量池如果没有该字符串，先将堆中字符串放入字符串常量池，然后返回字符串常量池相应的地址\n//        String b = a.intern();\n//        // a 是堆中的引用 b是常量池中的引用 因此为false\n//        System.out.println(a == b);')]),n._v(" "),r("p",[n._v('//        String s = new String("1");\n//        String t = new String("1");\n//        String x = new String("1") + new String("1"); // 生成在堆中，而不是字符串常量池\n//        String s1 = s.intern();\n//        String s2 = "1";\n//        String s3 = "11";\n//        System.out.println(s == s1); // false\n//        System.out.println(s1 == s2); // true\n//        System.out.println(s == t); // false\n//        System.out.println(s.intern() == t.intern()); // true\n//        System.out.println(x == s3);  // false\n//        System.out.println(x.intern() == s3.intern());  // true')]),n._v(" "),r("pre",[r("code",[n._v('    // x 指向堆\n    String x = new String("1") + new String("1");\n    // x1 指向堆\n    String x1 = new String("1") + "1";\n    String x2 = "1" + "1";\n    String s3 = "11";\n\n    System.out.println(x == s3);  // false\n    System.out.println(x1 == s3);  // false\n    System.out.println(x2 == s3); // true\n\n\n\n\n}\n')])]),n._v(" "),r("p",[n._v("}")])])}),[],!1,null,null,null);t.default=s.exports}}]);