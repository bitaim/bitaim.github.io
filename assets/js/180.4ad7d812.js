(window.webpackJsonp=window.webpackJsonp||[]).push([[180],{388:function(t,e,r){"use strict";r.r(e);var s=r(0),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"命令模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#命令模式"}},[t._v("#")]),t._v(" 命令模式")]),t._v(" "),r("p",[t._v("  命令模式将请求（命令）封装成一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加功能）。")]),t._v(" "),r("p",[t._v("  对于游戏这种复杂度集中在客户端，后端基本上只负责数据（比如积分、生命值、装备）的更新和查询，所以后端逻辑相对于客户端来说，要简单很多。")]),t._v(" "),r("p",[t._v("  在游戏中为了提高性能，会把游戏中玩家的信息保存在内存中。在游戏进行的过程中，只更新内存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务器上。这样，一个玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器去查找了，实现起来就简单了许多。")]),t._v(" "),r("p",[t._v("  一般来说，游戏客户端和服务端之间的数据交互是比较频繁的。所以，为了节省网络连接建立的开销，客户端和服务端之间一般采用长连接的方式来通信。通信的格式有很多种，比如Protocol Buffer，JSON，XML等，甚至可以自定义格式。不管是什么格式，客户端发送给服务器的请求，一般都包括两部分内容：指令和数据。其中，指令也可以称为事件，数据是执行这个指令所需的数据。")]),t._v(" "),r("p",[t._v("  服务器端轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求包含的数据和处理逻辑封装成命令对象，并存储在内存队列中。然后再从队列中取出一定数量的命令来执行。执行完成之后，在重新开始新的一轮轮询。")])])}),[],!1,null,null,null);e.default=n.exports}}]);