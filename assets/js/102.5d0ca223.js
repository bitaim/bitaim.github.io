(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{384:function(o,_,v){"use strict";v.r(_);var e=v(14),r=Object(e.a)({},(function(){var o=this,_=o.$createElement,v=o._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[v("h1",{attrs:{id:"日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#日志"}},[o._v("#")]),o._v(" 日志")]),o._v(" "),v("p",[o._v("  通过一次完整的写操作流程，引入MySQL中非常重要的三个日志，redolog重做日志、undolog回滚日志、binlog归档日志。")]),o._v(" "),v("h2",{attrs:{id:"写操作流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#写操作流程"}},[o._v("#")]),o._v(" 写操作流程")]),o._v(" "),v("p",[o._v("  （1）执行器调用存储引擎的接口，获取数据。")]),o._v(" "),v("p",[o._v("  （2）如果要写的数据对应的数据页已经在内存（buffer pool）中，直接返回给执行器。如果不在内存中，存储引擎会查找对应的数据页加载到内存中，然后返回给执行器。")]),o._v(" "),v("p",[o._v("  （3）执行器执行相关操作，调用存储引擎接口写入新数据。")]),o._v(" "),v("p",[o._v("  （4）存储引擎将新数据更新到内存（buffer pool）中，同时将更新操作记录到redo log里，此时redo log处于prepare状态。然后返回执行器成功。")]),o._v(" "),v("p",[o._v("  （5）执行器生成相关操作的binlog，并把binlog写入磁盘。")]),o._v(" "),v("p",[o._v("  （6）执行器调用存储引擎的提交事务接口，存储引擎把刚刚写入的redo log修改为commit状态，更新完成。redo log的写入分成两个步骤，prepare和commit，这就是"),v("strong",[o._v("两阶段提交")]),o._v("。")]),o._v(" "),v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/ee/2a/ee9af616e05e4b853eba27048351f62a.jpg",width:"400px"}}),o._v(" "),v("h2",{attrs:{id:"redo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[o._v("#")]),o._v(" redo log")]),o._v(" "),v("p",[o._v("  如果每次写操作都要落盘，磁盘也需要定位到具体位置，整个过程IO成本，查找成本都很高。为了避免这个问题，引入了redolog重做日志。redolog日志是InnoDB引擎特有的日志，是一种物理日志，记录的是在哪个物理页做了什么修改。")]),o._v(" "),v("p",[o._v("  当更新数据时，直接修改内存中的数据页，然后将对数据页的修改记录在redolog中，也就是"),v("strong",[o._v("先写日志，再写磁盘")]),o._v("。")]),o._v(" "),v("p",[o._v("  redo log保证了写入内存数据页的数据，如果还没有flush到磁盘，是不会丢失的。即使MySQL异常宕机重启，还没有来得及flush到磁盘的数据，也会从redo log日志中恢复到内存中，这个能力称为"),v("strong",[o._v("crash-safe")]),o._v("。")]),o._v(" "),v("p",[v("strong",[o._v("  redolog主要节省的是随机写磁盘的IO消耗，change buffer主要节省的是随机读磁盘的IO消耗")]),o._v("。如果磁盘有好几TB，那么redo log直接设置为4个文件，每个文件1GB。")]),o._v(" "),v("p",[v("strong",[o._v("1、redolog 是如何写入的")])]),o._v(" "),v("p",[o._v("  redolog的日志大小是固定的，写入是追加写操作，从头开始写，写到末尾又回到开头循环写。redolog的日志中有两个指针，"),v("strong",[o._v("checkpoint")]),o._v("和"),v("strong",[o._v("write pos")]),o._v("，如下图所示。如果write pos追上了checkpoint，就无法执行新的写操作。就需要flush掉一部分脏页，把checkpoint推进一下。")]),o._v(" "),v("img",{attrs:{src:"/数据库/redo log.png",width:"450px"}}),o._v(" "),v("p",[o._v("  redolog本质也是磁盘文件，写入也是需要IO成本的。在一个事务中，对数据库的多个增删改操作，首先写入到redolog buffer内存中。")]),o._v(" "),v("p",[o._v("  在"),v("strong",[o._v("事务未提交的场景")]),o._v("下，后台有一个线程每隔1秒钟，将redolog buffer中的日志write到page cache，然后调用fsync持久化到磁盘。另外，当redolog buffer空间使用过半，也会write到page cache。")]),o._v(" "),v("p",[o._v("  在"),v("strong",[o._v("事务提交的场景")]),o._v("下，需要根据redo log的写入策略决定，是由"),v("code",[o._v("innodb_flush_log_at_trx_commit")]),o._v("参数控制的。")]),o._v(" "),v("ol",[v("li",[o._v("当为0时，表示每次事务提交时，不做处理，也就是留在redo log buffer里。")]),o._v(" "),v("li",[o._v("当为1时，表示每次事务提交时，将redo log buffer中的日志持久化到磁盘。另外其他事务的提交操作，也会将redo log buffer中的日志持久化到磁盘。")]),o._v(" "),v("li",[o._v("当为2时，表示每次事务提交时，将redo log buffer中的日志write到page cache中，并没有持久化到磁盘。")])]),o._v(" "),v("p",[v("strong",[o._v("2、flush刷脏")])]),o._v(" "),v("p",[o._v("  当内存数据页与磁盘数据页内容不一致时，这个内存数据页就被称为"),v("strong",[o._v("脏页")]),o._v("。内存数据页写入到磁盘后，内存和磁盘上的数据页内容就一致了，称为干净页，这个过程叫做"),v("strong",[o._v("刷脏页（flush")]),o._v("）。")]),o._v(" "),v("p",[v("strong",[o._v("1、flush的时机")])]),o._v(" "),v("ol",[v("li",[o._v("InnoDB引擎的redo log日志写满了。这时系统会停止所有更新操作，把check point往前推进，让redo log继续有空间可以写。")]),o._v(" "),v("li",[o._v("系统内存不足时。当需要新的内存数据页，而内存不够用的时候。就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是脏页，就必须将脏页刷到磁盘。")]),o._v(" "),v("li",[o._v("当系统空闲时，会主动刷脏页。")]),o._v(" "),v("li",[o._v("当MySQL正常关闭的时候，将内存中的脏页全部flush到磁盘上。")])]),o._v(" "),v("p",[v("strong",[o._v("2、如何优化")])]),o._v(" "),v("p",[o._v("  对于InnoDB的redo log日志写满这种情况，要尽量避免。当出现这种情况时，整个系统的更新操作是不可用的。")]),o._v(" "),v("p",[o._v("  而内存不足，要先将脏页刷到磁盘，这种情况是常态。buffer pool内存池的内存页有三种状态，未使用的、使用了的干净页、使用了的脏页。当要读入的数据页没有在内存时，就必须到缓存池中申请一个数据页。只能把最久不使用的数据页从内存中淘汰掉，如果淘汰的是干净页，就直接释放出来使用。如果淘汰的是脏页，就必须将脏页刷到磁盘，成为干净页才能复用。"),v("strong",[o._v("刷脏页的过程会占用资源，可能会使更新和查询语句的响应时间变长")]),o._v("。")]),o._v(" "),v("p",[o._v("  要避免两种情况，否则会明显影响性能。一是一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显边长。二是redo log日志写满，更新全部堵住，写性能为0。")]),o._v(" "),v("p",[v("strong",[o._v("3、刷脏的策略控制")])]),o._v(" "),v("p",[o._v("  确定主机的IO能力，明确给InnoDB存储引擎，保证以最大能力刷脏。通过"),v("code",[o._v("innodb_io_capacity")]),o._v("参数控制，建设设置为磁盘的IOPS。可以通过fio工具来测试，测试磁盘随机读写的命令是"),v("code",[o._v("fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest")])]),o._v(" "),v("p",[v("strong",[o._v("4、刷脏的连坐策略")])]),o._v(" "),v("p",[o._v("  一旦一个查询需要先flush掉一个脏页时，如果这个脏页旁边的数据页也是脏页，这个判断还可以传递，导致查询效率变慢。通过参数"),v("code",[o._v("innodb_flush_neighbors")]),o._v("控制。这个策略在机械硬盘时代很有意义，可以减少很多随机IO。如果是SSD这类IOPS比较高的设备，建议把"),v("code",[o._v("innodb_flush_neighbors")]),o._v("的值设置为0。在MySQL8.0时，这个参数默认是0。")]),o._v(" "),v("h2",{attrs:{id:"undolog-回滚日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#undolog-回滚日志"}},[o._v("#")]),o._v(" undolog 回滚日志")]),o._v(" "),v("p",[o._v("  回滚日志，有两个作用。一是，做事务的回滚操作，保证事务的原子性。二是，实现记录行的多版本。")]),o._v(" "),v("p",[o._v("  表中的每一条记录行，都有两个隐藏的列，"),v("code",[o._v("trx_id")]),o._v("事务id 和 "),v("code",[o._v("roll_pointer")]),o._v("回滚指针。事务id表示当前记录行的最新版本，回滚指针指向回滚日志。")]),o._v(" "),v("p",[o._v("  在一个事务中，当执行写操作时。首先要记录一条undo log回滚日志，再执行真正的写操作，同时将记录行的事务ID更新为当前事务的ID。当执行回滚操作时，只需要根据回滚指针，找到回滚日志，执行逻辑命令恢复更新前数据即可。")]),o._v(" "),v("p",[o._v("  回滚日志不能随便删除，因为要保证不同版本的查询。存储引擎中存储的是数据的最新版本，不管你提交还是没有提交。然后由回滚指针指向回滚日志，回滚日志中也有指针再指向下一条回滚日志。")]),o._v(" "),v("p",[o._v("  回滚日志会根据系统当前活跃的事务id，删除版本旧的回滚日志。避免使用长事务，长事务意味着会存在很老的事务视图，占用存储空间。")]),o._v(" "),v("h2",{attrs:{id:"归档日志-binlog"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#归档日志-binlog"}},[o._v("#")]),o._v(" 归档日志 binlog")]),o._v(" "),v("p",[o._v("  binlog是MySQL Server层共有的日志，所有的存储引擎都可以使用。binlog是逻辑日志，记录的是原始的语句。binlog是可以追加写入的，写到一定大小后会自动切换到下一个，不会覆盖之前的日志。通过定期备份binlog，可以实现"),v("strong",[o._v("归档")]),o._v("的功能。")]),o._v(" "),v("p",[v("code",[o._v("sync_binlog")]),o._v("建议设置为1，表示每次事务的binlog都持久化到磁盘。保证MySQL异常重启后binlog不丢失。")])])}),[],!1,null,null,null);_.default=r.exports}}]);