(window.webpackJsonp=window.webpackJsonp||[]).push([[268],{548:function(a,t,_){"use strict";_.r(t);var v=_(14),r=Object(v.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"分布式事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[a._v("#")]),a._v(" 分布式事务")]),a._v(" "),_("h2",{attrs:{id:"_2pc-3pc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2pc-3pc"}},[a._v("#")]),a._v(" 2PC 3PC")]),a._v(" "),_("p",[a._v("  基于DTP模型的XA事务，其具体实现有两阶段提交，这种属于刚性事务，前提是数据库要支持这种模式。可以用来解决跨库事务。")]),a._v(" "),_("p",[a._v("  劣势是对资源加锁时间变长，性能差。")]),a._v(" "),_("h2",{attrs:{id:"可靠消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可靠消息"}},[a._v("#")]),a._v(" 可靠消息")]),a._v(" "),_("p",[a._v("  可靠消息是实现分布式事务最重要、最常用的"),_("strong",[a._v("柔性事务")]),a._v("方案，能够保证上下游数据的"),_("strong",[a._v("最终一致性")]),a._v("。")]),a._v(" "),_("p",[a._v("  创建本地消息表，将业务与消息放入同一个本地事务。在事务结束后，使用MQ发送消息，接收Broker端的消息回执后更新本地消息表的发送状态。同时配合定时任务，扫描本地消息表发送失败的消息进行重试，必要时人工介入。")]),a._v(" "),_("p",[a._v("  上述方案是基于MQ可靠消息的统一方案。另外RocketMQ支持事务消息，实现会更加简单。")]),a._v(" "),_("h2",{attrs:{id:"tcc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcc"}},[a._v("#")]),a._v(" TCC")]),a._v(" "),_("p",[a._v("  TCC同样是解决分布式事务的一种"),_("strong",[a._v("柔性事务")]),a._v("方案，能够保证上下游数据的"),_("strong",[a._v("最终一致性")]),a._v("。相比2PC模式，具有更强的灵活性和性能优势。TCC模式本质上是基于服务层的2PC编程模式，把数据库层的事务逻辑抽象到业务服务层，通过服务层业务逻辑实现服务的补偿模式。")]),a._v(" "),_("p",[a._v("  TCC：Try（锁定资源）、Confirm（使用资源）、Cancel（释放资源），实现某个功能需要提供三个方法，加大了开发成本。调用这两个服务的Try方法，全部执行成功后，调用Confirm方法，其中一个Try阶段失败，则执行回滚逻辑。Try阶段成功，要求Confirm阶段一定成功。Try阶段一般做业务的检查和资源的预留。")]),a._v(" "),_("p",[a._v("  TCC与其他方案的区别是，TCC允许分布式事务失败，而其他方案是"),_("strong",[a._v("尽全力保证分布式事务成功")]),a._v("。")]),a._v(" "),_("h2",{attrs:{id:"seata"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#seata"}},[a._v("#")]),a._v(" Seata")]),a._v(" "),_("p",[a._v("  Seata阿里开源的分布式事务框架，支持XA、AT、Saga、TCC四种模式，默认是AT模式。")]),a._v(" "),_("h3",{attrs:{id:"at模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#at模式"}},[a._v("#")]),a._v(" AT模式")]),a._v(" "),_("p",[a._v("https://blog.csdn.net/weixin_38582851/article/details/123042833")]),a._v(" "),_("p",[a._v("  前提。基于支持本地ACID事务的关系型数据库。Java应用，通过JDBC访问数据库。")]),a._v(" "),_("p",[a._v("  整体机制。两阶段提交协议的演变。一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。二阶段：提交异步化，非常快速的完成。回滚通过一阶段的回滚日志进行反向补偿。")]),a._v(" "),_("p",[a._v("  使用方式。事务参与者在自己库里创建UNDO_LOG表。对分布式事务加全局锁，避免脏写。还要加一些直接操作数据的一些其他本地事务加入到全局锁的竞争中，避免脏写。")]),a._v(" "),_("p",[a._v("  原理。Seata会代理每一个本地事务，在事务执行前把数据复制一份（before_image），在执行SQL语句，其次再把操作后的数据复制一份（after_image），最后释放行锁，第一阶段结束。第二阶段如果是提交操作，删除UNDO_LOG中的日志即可。第二阶段如果是回滚操作，就要基于UNDO_LOG对数据进行回滚。")]),a._v(" "),_("p",[a._v("  隔离级别。Seata的分布式事务本质是多个本地事务，在全局事务执行中，某个本地事务已经提交了。如果Seata没有采取错误，则会导致已提的本地事务被读取，造成脏读，如果数据在全局事务提交前被修改，则会造成脏写。")]),a._v(" "),_("p",[a._v("  如果要达到Seata的分布式事务的读已提交隔离级别，全局事务提交之后，数据才可以被读取。Seata提供了全局锁机制实现全局事务读已提交。但是默认情况下，Seata的全局事务是工作在读未提交隔离级别的，保证绝大多数场景的高效性。")]),a._v(" "),_("p",[a._v("  @GlobalTransactional注解 是用于全局事务竞争全局锁。")]),a._v(" "),_("p",[a._v("  @GlobalLock是用于本地事务来竞争全局锁。只不过不需要开启全局事务，只在本地事务提交前，检查全局锁是否存在。存在则抛异常。")]),a._v(" "),_("h3",{attrs:{id:"saga模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#saga模式"}},[a._v("#")]),a._v(" Saga模式")]),a._v(" "),_("p",[a._v("  核心理念是将事务切分为一组依次执行的短事务，也可以理解成基于业务补偿逻辑实现分布式下的高性能分布式事务模式。较之基于单一数据库资源访问的本地事务，分布式事务的应用架构更为复杂。")])])}),[],!1,null,null,null);t.default=r.exports}}]);