(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{406:function(a,t,s){"use strict";s.r(t);var n=s(14),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[a._v("#")]),a._v(" 面试题")]),a._v(" "),s("h2",{attrs:{id:"_1、为什么需要java序列化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、为什么需要java序列化"}},[a._v("#")]),a._v(" 1、为什么需要Java序列化")]),a._v(" "),s("p",[a._v("Java中的对象通过实现"),s("code",[a._v("Serializable")]),a._v("接口来实现序列化。被"),s("code",[a._v("static")]),a._v("或者"),s("code",[a._v("transient")]),a._v("修饰的字段是不会参与序列化的。")]),a._v(" "),s("p",[a._v("在JVM运行期间，对象都是分配在内存中的。如果想要把这些对象保存到磁盘上或者通过网络传输到其他机器上，就需要序列化将这些对象转化成字节数据。")]),a._v(" "),s("h2",{attrs:{id:"_2、什么是spi"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、什么是spi"}},[a._v("#")]),a._v(" 2、什么是SPI")]),a._v(" "),s("p",[a._v("SPI全称叫Service Provider Interface，在Java6时引入的该功能。可以在运行时动态给一个接口添加实现，只需要在"),s("code",[a._v("src/MATE-INF/services/")]),a._v("目录下创建一个文件。")]),a._v(" "),s("p",[a._v("文件命名为接口的全限定名。")]),a._v(" "),s("p",[a._v("内容填具体的实现类的全限定名，可以填写多个实现类，换行写即可。")]),a._v(" "),s("p",[a._v("SPI机制就是为某个接口寻找实现的机制，核心便是解耦，通过SPI机制，将实现类隐藏在接口后面，根据需要寻找服务实现。")]),a._v(" "),s("p",[a._v("有不少框架用它来做服务的拓展发现，比如MySQL、Spring、Dubbo。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ServiceLoader")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HelloService")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" helloServices "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ServiceLoader")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("load")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HelloService")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nhelloServices"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("forEach")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HelloService")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("sayHello")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("h2",{attrs:{id:"_3、equlas和hashcode"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、equlas和hashcode"}},[a._v("#")]),a._v(" 3、equlas和hashCode")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// hashcode是根据对象的内存地址经哈希算法得来的")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("native")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    \n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 比较地址")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[s("code",[a._v("hashCode()")]),a._v("的默认实现是根据对象的内存地址经过哈希算法得来的。重写后的方法是对各个字段进行哈希运算。\n"),s("code",[a._v("equals()")]),a._v("方法默认比较的是对象的地址。重写后的方法是对各个字段进行比较，确定对象是否相同。")]),a._v(" "),s("p",[a._v("当使用HashMap等散列表添加元素时，如果key是自定义对象时，需要重写这两个方法。")]),a._v(" "),s("p",[a._v("因为添加是通过hash值计算下标，而哈希值是有可能重复的，需要再通过"),s("code",[a._v("equals()")]),a._v("确定这两个对象是否相同。")]),a._v(" "),s("h2",{attrs:{id:"_4、switch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、switch"}},[a._v("#")]),a._v(" 4、switch")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SwitchTest")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" number "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("switch")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("number"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"我是0"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"我是1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"我是2"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("default")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"默认"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"我是3"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("结果会打印：默认、我是3。\n执行过程，首先匹配switch中的条件。如果找到相关执行条件，则一直向下执行。如果找不到相关执行条件，看看有没有default，如果找到该条件则继续向下执行，否则直接跳出循环。")]),a._v(" "),s("p",[a._v("如果向下执行过程中报错，则跳出switch循环。")]),a._v(" "),s("h2",{attrs:{id:"_5、对java的认识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、对java的认识"}},[a._v("#")]),a._v(" 5、对Java的认识")]),a._v(" "),s("p",[a._v("  Java是一门面向对象的语言。最显著的两个特性有两个方面，一是所谓的“"),s("strong",[a._v("Write once，run anywhere")]),a._v("”，书写一次，到处运行，能够非常容易地获得跨平台能力。另外就是"),s("strong",[a._v("垃圾收集")]),a._v("，Java通过垃圾回收器收集分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。")]),a._v(" "),s("p",[a._v("  我们开发的Java源代码，首先通过Javac编译成字节码。然后在运行时，通过Java虚拟机内嵌的解释器将字节码转换称为最终的机器码。但是常见的 JVM，比如我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT 能够在运行时"),s("strong",[a._v("将热点代码编译成机器码")]),a._v("，这种情况下部分热点代码就属于编译执行，而不是解释执行了。所以"),s("strong",[a._v("Java是一门解释和编译的语言")]),a._v("。")]),a._v(" "),s("p",[a._v("  通常会把Java分为编译期和运行时。编译期是指将Java源代码编译成字节码的过程，而不是直接可以执行的机器码。Java通过字节码和Java虚拟机这种跨平台的抽象，屏蔽了操作系统和硬件的细节，这也是实现“一次编译，到处运行”的基础。")]),a._v(" "),s("p",[a._v("  在运行时，JVM会通过类加载器加载字节码，解释或者编译执行。在JDK8中是解释和编译混合的一种模式。Oracle Hotspot JVM内置了两个不同的JIT compiler，分为client和server。client客户端模式适合于对于启动速度敏感的应用，比如普通的Java桌面应用。server服务端模式，是为长时间运行的服务器端应用设计的。")]),a._v(" "),s("h2",{attrs:{id:"_6、exception和error"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6、exception和error"}},[a._v("#")]),a._v(" 6、Exception和Error")]),a._v(" "),s("p",[a._v("  Exception和Error都是继承自Throwable类，在Java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch）。")]),a._v(" "),s("p",[a._v("  Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。Exception又分为"),s("strong",[a._v("可检查")]),a._v("和"),s("strong",[a._v("不检查")]),a._v("异常。")]),a._v(" "),s("p",[a._v("  可检查异常在源代码里必须显示地进行捕获处理，比如"),s("code",[a._v("IOException")]),a._v("，继承自"),s("code",[a._v("Exception")]),a._v("类的子类，这是编译期检查的一部分。")]),a._v(" "),s("p",[a._v("  不检查异常就是所谓的运行时异常，比如"),s("code",[a._v("NullPointerException")]),a._v("、"),s("code",[a._v("ArrayIndexOfBoundsException")]),a._v("，继承自"),s("code",[a._v("RuntimeException")]),a._v("类的子类。通常是可以编码避免的逻辑处理，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。可能更希望"),s("code",[a._v("RuntimeException")]),a._v("被扩散出来，而不是被捕获。")]),a._v(" "),s("p",[a._v("  Error是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（JVM自身）处于非正常的、不可恢复的状态。既然是非正常的情况，所以不便于也不需要捕获，比如常见的"),s("code",[a._v("OutOfMemoryError")]),a._v("之类，都是Error的子类。")]),a._v(" "),s("p",[a._v("  对于异常处理的两个基本原则。第一，"),s("strong",[a._v("尽量不要捕获类似Exception这样的通用异常，而是应该捕获特定异常")]),a._v("。第二，不要"),s("strong",[a._v("生吞异常")]),a._v("。")]),a._v(" "),s("p",[a._v("  要让尽早地暴露出去，也是快速失败的思想。"),s("code",[a._v('Objects.requireNonNull(data,"data must not be null");')])]),a._v(" "),s("p",[a._v("  当捕获异常后，如果不知道如何处理，可以选择保留原有异常的cause信息，直接再抛出去或者构建新的异常抛出去。在更高层面，因为有了清晰的业务逻辑，往往会更清楚合适的处理方式是什么。在保证诊断信息足够的同时，也要开率避免包含敏感信息，那样可能导致潜在的安全问题。")]),a._v(" "),s("p",[a._v("  try-catch代码块会产生额外的性能开销，往往会影响JVM对代码进行优化，所以建议仅捕获必要的代码块，尽量不要一个大的try块包住整段代码。与此同时，利用异常控制代码流程，也不是一个好主意，远比通常情况下的"),s("code",[a._v("if/else\\switch")]),a._v("要低效。Java每实例一个Exception，就会对当前的栈进行快照，这是一个相对比较重的操作。")]),a._v(" "),s("h2",{attrs:{id:"_7、谈谈final、finally、-finalize有什么不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7、谈谈final、finally、-finalize有什么不同"}},[a._v("#")]),a._v(" 7、谈谈final、finally、 finalize有什么不同？")]),a._v(" "),s("p",[a._v("  final修饰的类不能被继承，final修饰的方法不能被重写，final修饰的变量不可以修改。")]),a._v(" "),s("p",[a._v("  将方法或者类声明为final，明确地告诉别人，这些行为是不允许修改的。在Java库中许多类都被final修饰，可以有效避免API使用者更改基础功能，在某种程度上，这是保证平台安全的必要手段。")]),a._v(" "),s("p",[a._v("  使用final修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误。甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成final。")]),a._v(" "),s("p",[a._v("  final变量产生了某种程度的不可变的效果。所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值final变量，有利于减少额外地同步开销，也可以省去一些防御性拷贝的必要。")]),a._v(" "),s("p",[a._v("  finally则是Java保证重点代码一定要被执行的一种机制。比如在finally进行解锁操作，或者关闭连接等资源，推荐使用Java7中添加的"),s("code",[a._v("try-with-resources")]),a._v("语句。")]),a._v(" "),s("p",[a._v("  finalize是基础类Object的一个方法，设计目的是保证对象在被垃圾回收前完成特定资源的回收，可能会导致拖慢垃圾回收，导致大量对象堆积。finalize机制现在已经不推荐使用，并且在JDK9被标记为过期方法。")]),a._v(" "),s("p",[a._v("  Java平台目前在逐步使用"),s("code",[a._v("java.lang.ref.Cleaner")]),a._v("来替换原有的"),s("code",[a._v("finalize")]),a._v("实现。"),s("code",[a._v("Cleaner")]),a._v("的实现利用了幻象引用（PhantomReference），这是一种常见的所谓post-mortem清理机制。吸取了finalize里的教训，每个Cleaner的操作都是独立的，它有自己的运行线程，所以可以避免意外死锁的情况。")]),a._v(" "),s("p",[a._v("  注意，从可预测性的角度来判断，Cleaner 或者幻象引用改善的程度仍然是有限的，如果由于种种原因导致幻象引用堆积，同样会出现问题。所以，Cleaner 适合作为一种最后的保证手段，而不是完全依赖 Cleaner 进行资源回收，不然我们就要再做一遍 finalize 的噩梦了。")]),a._v(" "),s("h2",{attrs:{id:"_8、强、软、弱、虚引用的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8、强、软、弱、虚引用的区别"}},[a._v("#")]),a._v(" 8、强、软、弱、虚引用的区别？")]),a._v(" "),s("p",[a._v("  在Java语言中，除了原始数据类型的变量（byte、short、int、long、double、float、char、boolean），其他所有都是引用类型，指向各种不同的对象。理解引用对于掌握Java对象生命周期和JVM内部相关机制非常有帮助。")]),a._v(" "),s("p",[a._v("  不同的引用类型，主要体现的是对象不同的可达性状态和对垃圾收集的影响。")]),a._v(" "),s("p",[a._v("  强引用。最常见的普通对象，只要还有强引用指向一个对象，就能表明对象还活着，垃圾回收器就不会碰这类对象。")]),a._v(" "),s("p",[a._v("  软引用，是一种相对强引用弱化一些的引用。只有当JVM认为内存不足时，才会去试图回收软引用指向的对象。JVM会确保在抛出"),s("code",[a._v("OutOfMemoryError")]),a._v("之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉。这样就保证了使用缓存的同时，不会耗尽内存。")]),a._v(" "),s("p",[a._v("  弱引用，并不能使对象豁免垃圾收集，仅仅提供一种访问在弱引用对象的途径。可以用来构建一种没有特定约束的关系，比如维护一种非强制性的映射关系。如果试图获取时对象还在，就使用，否则重新实例化。同样是许多缓存实现的选择。")]),a._v(" "),s("p",[a._v("  虚引用，也被称为幻想引用。不能通过它访问对象。")])])}),[],!1,null,null,null);t.default=e.exports}}]);