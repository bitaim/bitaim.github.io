(window.webpackJsonp=window.webpackJsonp||[]).push([[162],{361:function(v,_,s){"use strict";s.r(_);var e=s(0),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h1",{attrs:{id:"redis缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis缓存"}},[v._v("#")]),v._v(" Redis缓存")]),v._v(" "),s("p",[s("strong",[v._v("  高性能")]),v._v("。底层通过C语言编写，是一个内存型数据库，通讯采用epool非阻塞I/O多路复用机制。减少了线程切换时上下文的切换和竞争。")]),v._v(" "),s("p",[s("strong",[v._v("  线程安全")]),v._v("。Redis的操作都是单线程的，保证了原子操作，在高并发的场景下保证了数据安全。减少了线程切换时上下文的切换和竞争。而多线程体现了网络协议解析和同步数据上。")]),v._v(" "),s("p",[s("strong",[v._v("  功能丰富")]),v._v("。数据结构有：String、List、HashSet、SortedSet、GEO、BitMap、HyperLogLog。")]),v._v(" "),s("p",[s("strong",[v._v("  架构丰富")]),v._v("。有应对高并发的"),s("strong",[v._v("主从架构")]),v._v("，应对高可用的"),s("strong",[v._v("哨兵架构")]),v._v("，应对大数据量的"),s("strong",[v._v("集群架构")]),v._v("。")]),v._v(" "),s("p",[v._v("  支持事务，支持对几个操作合并后的原子性执行。")]),v._v(" "),s("h2",{attrs:{id:"内存管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[v._v("#")]),v._v(" 内存管理")]),v._v(" "),s("p",[s("strong",[v._v("1、Redis是如何清理内存的")]),v._v("？")]),v._v(" "),s("p",[s("strong",[v._v("  （1）定期删除")]),v._v("。Redis默认每隔100ms随机"),s("strong",[v._v("抽取一部分")]),v._v("设置了过期时间的key，如果key已过期就将其删除。并不会遍历所有的key，因为会影响性能。")]),v._v(" "),s("p",[s("strong",[v._v("  （2）惰性删除")]),v._v("。当获取某个key时，如果设置了过期时间并且已过期就将其删除，同时返回空。")]),v._v(" "),s("p",[s("strong",[v._v("  （3）内存淘汰机制")]),v._v("。定期删除和惰性删除两种方式，只是删除了部分过期的key，还是会存在过期的数据未被及时清理而被滞留在内存中。Redis引入了"),s("strong",[v._v("内存淘汰机制")]),v._v("，根据设置的策略进行内存清理。当"),s("strong",[v._v("执行写操作而内存不足时会触发内存淘汰机制")]),v._v("，通过"),s("strong",[v._v("LRU算法")]),v._v("自动清理掉最近最少使用的数据。")]),v._v(" "),s("p",[s("strong",[v._v("2、内存淘汰机制策略")])]),v._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[v._v("noeviction：默认策略。内存不足时，写入数据报错。\nallkeys-lru：最常用策略。在所有的key中，移除最近最少使用的key。\nallkeys-random：在所有的key中，随机移除key。\nvolatile-lru：在设置了过期时间的key中，移除最近最少使用的key。\nvolatile-random：在设置了过期时间的key中，随机移除key。\nvolatile-ttl：在设置了过期时间的key中，移除马上要过期的key。\n")])])]),s("p",[v._v("  Redis部分配置如下。")]),v._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[v._v("maxmemory-policy noeviction\n")])])]),s("p",[s("strong",[v._v("3、缓存中数据丢失的原因")])]),v._v(" "),s("p",[v._v("  （1）对key设置了过期时间，被定期删除和惰性删除给干掉了。")]),v._v(" "),s("p",[v._v("  （2）内存不足时被内存淘汰机制给干掉了。")]),v._v(" "),s("h2",{attrs:{id:"持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[v._v("#")]),v._v(" 持久化")]),v._v(" "),s("p",[s("strong",[v._v("1、为什么需要持久化？")])]),v._v(" "),s("p",[v._v("  Redis持久化主要目的是"),s("strong",[v._v("数据备份")]),v._v("和"),s("strong",[v._v("故障恢复")]),v._v("。Redis的数据是存储在内存中的，如果Redis由于某些原因挂掉，那么重启后就会造成数据丢失。")]),v._v(" "),s("p",[v._v("  数据丢失就会出现缓存未命中的情况，请求全部打到数据库层面，会给数据库巨大的压力，很可能会导致数据库挂掉，导致整个系统不可用。")]),v._v(" "),s("p",[v._v("  如果做好了持久化，当重启Redis时，就可以基于日志文件迅速恢复数据到内存中，"),s("strong",[v._v("尽快恢复业务")]),v._v("。")]),v._v(" "),s("p",[s("strong",[v._v("2、持久化该如何选择？")])]),v._v(" "),s("p",[v._v("  在生产环境中，综合使用RDB和AOF两种持久化方式。通过AOF文件来保证数据不丢失，作为数据恢复的第一选择。通过RDB文件来做不同程度的冷备。")]),v._v(" "),s("p",[v._v("  持久化有三种方式，"),s("strong",[v._v("RDB、AOF、混合持久化")]),v._v("三种方式。在Redis4.0版本之后，选择混合持久化方式。")]),v._v(" "),s("p",[v._v("  当RDB方式和AOF方式同时开启时，Redis优先使用AOF文件来恢复数据，因为其数据更完整。")]),v._v(" "),s("h3",{attrs:{id:"rdb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[v._v("#")]),v._v(" RDB")]),v._v(" "),s("p",[v._v("  RDB是Redis默认开启的持久化方式，周期性（秒级，分钟级，可配置）的基于Redis当前内存中的数据生成一份完整的数据快照文件。也可以手动调用"),s("code",[v._v("save")]),v._v("或者"),s("code",[v._v("bgsave")]),v._v("命令，同步或者异步的方式生成RDB数据快照文件。")]),v._v(" "),s("p",[v._v("  可以对Redis进行设置，规则是"),s("strong",[v._v("在N秒内数据集至少有M个改动")]),v._v("，自动保存一次数据集，生成一份名为"),s("code",[v._v("dump.rdb")]),v._v("的二进制数据快照文件。")]),v._v(" "),s("p",[v._v("  Redis部分配置如下。")]),v._v(" "),s("div",{staticClass:"language-conf extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[v._v("# 在900秒内，有1个改动\nsave 900 1\n# 在300秒内，有10个改动\nsave 300 10\n# 在60秒内，有10000个改动\nsave 60 10000\n")])])]),s("p",[s("strong",[v._v("1、RDB执行流程")])]),v._v(" "),s("p",[v._v("  Redis通过调用"),s("code",[v._v("bgsave")]),v._v("命令fork一个子进程，子进程负责执行磁盘IO操作来进行持久化，父进程依然可以处理后续的客户端命令。")]),v._v(" "),s("p",[v._v("  fork一个子进程，子进程完全复制了父进程的资源，包括进程上下文、代码区、数据区、堆区、栈区等。")]),v._v(" "),s("p",[s("strong",[v._v("2、优点")])]),v._v(" "),s("p",[v._v("  （1）RDB方式会生成多个数据文件，每个数据文件代表某一时刻中的Redis内存中的数据快照，这种方式"),s("strong",[v._v("非常适合做冷备")]),v._v("。")]),v._v(" "),s("p",[v._v("  （2）RDB方式对Redis的性能影响非常小，可以让Redis保持高性能。")]),v._v(" "),s("p",[v._v("  （3）RDB方式相对于AOF方式，直接基于快照文件来重启和恢复Redis进程，更加快速。")]),v._v(" "),s("p",[s("strong",[v._v("3、缺点")])]),v._v(" "),s("p",[v._v("  （1）当发生故障时，RDB方式丢失的数据可能会比较多。这个问题也是RDB最大的缺点，因此不适合做数据恢复的第一优先方案。")]),v._v(" "),s("p",[v._v("  （2）RDB方式每次fork子进程来生成快照文件时，如果快照文件特别大。可能会导致Redis服务暂停数毫秒，甚至数秒。所以一般不要让RDB方式的间隔时间太长。")]),v._v(" "),s("h3",{attrs:{id:"aof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[v._v("#")]),v._v(" AOF")]),v._v(" "),s("p",[v._v("  AOF持久化方式记录每次对Redis所做的写操作，当Redis重启时，通过回放和执行AOF文件中的写指令来重新构建整个数据集。")]),v._v(" "),s("p",[v._v("  在现代操作系统中，写文件并不是直接写到磁盘上。而是先写入操作系统的缓存中，由操作系统按照策略将缓存中的数据刷到磁盘上。")]),v._v(" "),s("p",[v._v("  Redis中"),s("strong",[v._v("通常配置每隔一秒执行一次fsync函数")]),v._v("，来强制让操作系统将缓存中的数据刷到磁盘上。只有数据落盘，数据才是安全的。")]),v._v(" "),s("p",[v._v("  Redis部分配置如下。")]),v._v(" "),s("div",{staticClass:"language-conf extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[v._v("# 每次，严重影响性能\n# appendfsync always\n# 就是这个好\nappendfsync everysec\n# 不使用，依赖操作系统的策略进行刷盘\n# appendfsync no\n")])])]),s("p",[v._v("  当开启AOF持久化方式时，会将每次对Redis的写操作写到AOF文件中。当AOF文件大到一定程度时，会触发"),s("code",[v._v("rewrite")]),v._v("操作。就会基于当时Redis中的数据，来重新构建一个更小的AOF文件。")]),v._v(" "),s("p",[s("strong",[v._v("1、rewrite执行流程")])]),v._v(" "),s("p",[v._v("  （1）Redis首先fork一个子进程。子进程基于当前内存中的数据，构建到一个新的AOF文件。")]),v._v(" "),s("p",[v._v("  （2）Redis主进程，接收到客户端新的写操作时，在内存buffer中写入日志，同时写入旧的AOF文件。")]),v._v(" "),s("p",[v._v("  （3）当子进程写完日志后，Redis主进程将内存buffer中的新日志追加到新的AOF文件中。")]),v._v(" "),s("p",[v._v("  （4）然后用新的日志文件替换掉旧的日志文件即可。")]),v._v(" "),s("p",[s("strong",[v._v("2、优点")])]),v._v(" "),s("p",[v._v("  （1）AOF可以更好的保证数据不会丢失，最坏情况下丢失一秒钟的数据。")]),v._v(" "),s("p",[v._v("  （2）AOF日志文件以追加（append-only）的模式写入，没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易损坏。即使损坏，Redis提供了命令来修复。")]),v._v(" "),s("p",[v._v("  （3）AOF日志文件即使过大，当出现rewrite操作时也不会影响Redis的性能。因为会对其中的指令进行压缩，构建出一份恢复数据的最小日志。")]),v._v(" "),s("p",[v._v("  （4）AOF日志有很高的可读性，是可以人为看懂并修改的。比如不小心执行了"),s("code",[v._v("flushall")]),v._v("命令，在下一次"),s("code",[v._v("rewrite")]),v._v("命令之前，编辑AOF日志删除其中的"),s("code",[v._v("flushall")]),v._v("命令，重启Redis即可恢复数据。")]),v._v(" "),s("p",[s("strong",[v._v("3、缺点")])]),v._v(" "),s("p",[v._v("  （1）对于同一份数据，AOF日志通常会比RDB文件更大。")]),v._v(" "),s("p",[v._v("  （2）AOF开启后，支持的写QPS会比RDB方式写QPS低。因为每隔1秒执行一次"),s("code",[v._v("fsync")]),v._v("操作，但是性能还是很高的。")]),v._v(" "),s("p",[v._v("  （3）做数据恢复时比较慢。")]),v._v(" "),s("p",[v._v("  （4）如果用AOF文件来做冷备，需要手动编写复杂脚本来定时备份。")]),v._v(" "),s("h3",{attrs:{id:"混合持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合持久化"}},[v._v("#")]),v._v(" 混合持久化")]),v._v(" "),s("p",[s("strong",[v._v("1、背景")])]),v._v(" "),s("p",[v._v("  重启Redis时（不论是异常还是正常重启），我们很少使用RDB方式来恢复数据，因为会丢失大量数据。")]),v._v(" "),s("p",[v._v("  而如果使用AOF日志重放来恢复数据，性能相对RDB来说要慢很多。在启动Redis时，可能要花费很长的时间。")]),v._v(" "),s("p",[v._v("  因为Redis在4.0版本之后，引入了混合"),s("strong",[v._v("持久化机制")]),v._v("。但4.0版本的混合持久化功能是"),s("strong",[v._v("默认关闭")]),v._v("的，5.0版本则是"),s("strong",[v._v("默认开启")]),v._v("。")]),v._v(" "),s("p",[v._v("  可以通过"),s("code",[v._v("aof-use-rdb-preamble")]),v._v("配置参数控制该功能的启用，并同时开启AOF持久化方式。")]),v._v(" "),s("p",[s("strong",[v._v("2、混合持久化介绍")])]),v._v(" "),s("p",[v._v("  混合持久化同样是通过"),s("code",[v._v("bgrewriteaof")]),v._v("完成的，不同的是当开启混合持久化时，fork出的子进程先"),s("strong",[v._v("将内存副本全量的以RDB方式写入AOF文件")]),v._v("，然后在将"),s("code",[v._v("aof_rewrite_buf")]),v._v("重写缓冲区的增量命令以AOF方式追加到AOF文件中。并将新的含有RDB格式和AOF格式的AOF文件替换旧的AOF文件。")]),v._v(" "),s("p",[v._v("  新的AOF文件前半段是RDB格式的全量数据，后半段是AOF格式的增量数据。")]),v._v(" "),s("p",[v._v("  在Redis重启的时候，加载AOF文件进行数据恢复。先加载前半段的RDB数据内容，再加载剩余的AOF数据内容。结合两者的优势，"),s("strong",[v._v("既保证数据恢复启动快，又保证数据丢失少")]),v._v("。")]),v._v(" "),s("h3",{attrs:{id:"数据恢复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据恢复"}},[v._v("#")]),v._v(" 数据恢复")]),v._v(" "),s("p",[v._v("  在Redis同时开启两种持久化方式的情况下，如何做数据冷备恢复呢？")]),v._v(" "),s("p",[v._v("  （1）首先修改"),s("code",[v._v("redis.conf")]),v._v("配置文件，关系aof持久化方式。")]),v._v(" "),s("p",[v._v("  （2）复制"),s("code",[v._v(".rbd")]),v._v("文件到持久化目录下，启动Redis。启动过程会很慢，因为正在恢复数据。")]),v._v(" "),s("p",[v._v("  （3）热修改配置，使用"),s("code",[v._v("config set appendonly yes")]),v._v("命令开启aof持久化方式。")]),v._v(" "),s("p",[v._v("  （4）关闭Redis，物理修改配置文件开启aof持久化。重启Redis，完成冷备的数据恢复。")]),v._v(" "),s("p",[v._v("  在开启了两种持久化方式的情况下，如果持久化目录下没有aof文件，那么"),s("strong",[v._v("Redis启动会基于一个空的aof文件做数据恢复")]),v._v("。所以需要先关闭aof持久化方式。")])])}),[],!1,null,null,null);_.default=t.exports}}]);