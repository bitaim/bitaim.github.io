(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{367:function(_,e,t){"use strict";t.r(e);var v=t(0),s=Object(v.a)({},(function(){var _=this,e=_.$createElement,t=_._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"分布式锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[_._v("#")]),_._v(" 分布式锁")]),_._v(" "),t("h4",{attrs:{id:"_1、锁丢失"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、锁丢失"}},[_._v("#")]),_._v(" 1、锁丢失")]),_._v(" "),t("p",[_._v("  Redis在单节点的情况下，不存在锁丢失的问题。")]),_._v(" "),t("p",[_._v("  Redis在主从架构下，存在锁丢失的问题。因为主从之间同步是异步的，如果在主节点加锁成功后，指令还没有同步到从节点。此时主节点宕机，从节点被提升为主节点。那么新的主节点上并没有锁的数据，这就是锁丢失，此时其他客户端可以加锁成功。"),t("strong",[_._v("发生了同一时间下，多个客户端同时获得锁的情况")]),_._v("。")]),_._v(" "),t("p",[_._v("  由于redis的主从架构是AP模型，保证了数据最终一致性，可能会导致锁丢失的情况。那么来看一下强一致性的分布式锁方案。")]),_._v(" "),t("h4",{attrs:{id:"_2、zookeeper、etcd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、zookeeper、etcd"}},[_._v("#")]),_._v(" 2、zookeeper、etcd")]),_._v(" "),t("p",[_._v("  zookeeper采取zab协议，etcd采取raft协议（协议不了解，有时间学习一下）。")]),_._v(" "),t("p",[_._v("  zookeeper做分布式锁，利用了其"),t("strong",[_._v("临时顺序节点")]),_._v("的特性，但需要做写同步，所以其性能较差。etcd性能比zookeeper稍好。")]),_._v(" "),t("p",[_._v("  在互联网的应用中，其实不太关注数据的时效性，对于强一致性要求不是特别高，保证数据最终一致性即可。"),t("strong",[_._v("90%的场景都是使用Redis做分布式锁")]),_._v("。")]),_._v(" "),t("h4",{attrs:{id:"_3、redlock方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、redlock方案"}},[_._v("#")]),_._v(" 3、RedLock方案")]),_._v(" "),t("p",[_._v("  RedLock是Redis官方提供的方案，但在实际应用中使用的不多。")]),_._v(" "),t("p",[_._v("  RedLock的概念下需要至少奇数个Master主节点，比如3个。多个主节点之间相互独立，彼此之间不存在主从同步和数据赋值。")]),_._v(" "),t("p",[_._v("  如果在超过半数的机器上可以获取锁成功，则获取分布式锁成功。降级了多个客户端获取到锁的概率。")]),_._v(" "),t("p",[_._v("  因为需要部署多个节点，"),t("strong",[_._v("使用的资源（服务器）比较多，成本太大")]),_._v("。")]),_._v(" "),t("p",[_._v("  分布式锁的应用场景一般都是在高并发的情况下，因为需要对多个节点执行加锁和解锁命令，所以这种方式"),t("strong",[_._v("对性能的影响比较大")]),_._v("。")]),_._v(" "),t("h4",{attrs:{id:"_4、redisson"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、redisson"}},[_._v("#")]),_._v(" 4、Redisson")]),_._v(" "),t("p",[_._v("  Redisson方案是目前最常用的分布式锁方案，支持单机、主从、哨兵、集群的不同架构。")]),_._v(" "),t("p",[_._v("  底层通过"),t("strong",[_._v("lua脚本")]),_._v("对"),t("strong",[_._v("获取分布式锁，移除分布式锁")]),_._v("进行了封装，保证了其原子性。同时"),t("strong",[_._v("实现了可重入加锁")]),_._v("，lua脚本采用的是"),t("strong",[_._v("hset")]),_._v("的数据结构，可以记录获取锁的次数。")]),_._v(" "),t("h4",{attrs:{id:"_5、分布式锁的演化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、分布式锁的演化"}},[_._v("#")]),_._v(" 5、分布式锁的演化")]),_._v(" "),t("p",[_._v("  （1）利用redis的setnx特性，不存在时才可以设置成功。并配合expire命令，对锁设置过期时间，避免客户端意外宕机，锁无法被释放的问题。客户端在执行时，这是两条命令，没有保证原子性，无法保证锁百分百被添加过期时间。")]),_._v(" "),t("p",[_._v("  （2）利用redis的setnx ex命令，将获取锁和设置过期时间变成了一条原子命令。")]),_._v(" "),t("p",[_._v("  （3）如果客户端A获取分布式锁成功，但执行业务时很慢，分布式锁自动过期而被释放。此时客户端B就可以成功获取到分布式锁，"),t("strong",[_._v("此时出现多个客户端获取到锁的情况")]),_._v("。客户端A执行完毕调用del命令释放锁，结果"),t("strong",[_._v("客户端A释放了客户端B的锁，导致客户端C又可以获取锁")]),_._v("，这就乱套了。")]),_._v(" "),t("p",[_._v("  （4）因此这里就需要"),t("strong",[_._v("分布式锁的续期方案")]),_._v("，而redisson中使用看门狗替我们实现了这一逻辑。对于释放分布式锁，就需要客户端在"),t("strong",[_._v("获取分布式锁成功时，在value值中记录一个唯一值，释放锁时进行判断")]),_._v("。当前分布式锁的唯一值是否与我的相同，相同则释放。不同就不释放，避免释放掉其他客户端的锁。")])])}),[],!1,null,null,null);e.default=s.exports}}]);