(window.webpackJsonp=window.webpackJsonp||[]).push([[197],{478:function(t,a,s){"use strict";s.r(a);var r=s(14),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"异步更新缓存策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步更新缓存策略"}},[t._v("#")]),t._v(" 异步更新缓存策略")]),t._v(" "),s("h2",{attrs:{id:"队列-后台线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#队列-后台线程"}},[t._v("#")]),t._v(" 队列 + 后台线程")]),t._v(" "),s("p",[t._v("  采用更新和读取异步串行化的策略。")]),t._v(" "),s("h4",{attrs:{id:"方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方案"}},[t._v("#")]),t._v(" 方案")]),t._v(" "),s("p",[t._v("  （1）在JVM中维护多个队列，为每一个队列维护一个后台线程。将写请求和读请求进行封装，并根据数据的ID路由到不同队列。")]),t._v(" "),s("p",[t._v("  （2）后台线程负责处理队列的请求，这样可以将读写请求串行化，并将读请求积压到写请求之后，防止脏数据的产生。")]),t._v(" "),s("p",[t._v("  （3）对重复的读请求进行去重处理，减少队列中的重复请求。")]),t._v(" "),s("p",[t._v("  （4）由于读写均是异步操作，调用方在一定时间内要不停的轮询获取缓存结果。")]),t._v(" "),s("p",[t._v("  （5）如果在缓存中拿到数据就直接返回响应。如果超时，直接查询数据库并返回响应。")]),t._v(" "),s("p",[t._v("  更新请求过多，导致读取请求频繁超时，进而大量读取请求直接查询数据库。此时就需要部署多个服务节点，但要保证同一ID的请求路由到同一服务器。但还是不能保证热点商品频繁更新的特殊情况。")]),t._v(" "),s("h2",{attrs:{id:"中间件canal"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中间件canal"}},[t._v("#")]),t._v(" 中间件canal")])])}),[],!1,null,null,null);a.default=e.exports}}]);