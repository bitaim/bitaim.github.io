(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{486:function(t,_,v){"use strict";v.r(_);var e=v(14),s=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"http协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http协议"}},[t._v("#")]),t._v(" HTTP协议")]),t._v(" "),v("p",[t._v("  Http协议是最常用的"),v("strong",[t._v("应用层协议")]),t._v("。HTTP协议是建立在TCP/IP协议之上的。")]),t._v(" "),v("p",[v("strong",[t._v("1、一个Http数据包的结构")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("GET /test/index HTTP/1.1     // 第一部分请求行，包含请求类型，资源类型，HTTP版本\nCache-Control: max-age=0     // 第二部分请求头部，紧接着请求行之后的部分，\nAccept: text/html            // 用来说明服务器要使用的附加信息\nAccept-Language: zh-Hans-CN,zh-Hans;q=0.5\nUpgrade-Insecure-Requests: 1\nUser-Agent: Chrome/64.0.3282.140\nAccept-Encoding: gzip,deflate\nHost: 127.0.0.1:8080\nConnnection: Keep-Alive\n")])])]),v("p",[v("strong",[t._v("2、Http的请求格式")])]),t._v(" "),v("img",{attrs:{src:"/网络/HTTP请求格式.jpg"}}),t._v(" "),v("p",[v("strong",[t._v("3、Http的响应格式")])]),t._v(" "),v("img",{attrs:{src:"/网络/HTTP响应格式.jpg"}}),t._v(" "),v("p",[v("strong",[t._v("4、数据包是如何传递的")]),t._v("？")]),t._v(" "),v("p",[t._v("  Http请求首先封装成Http数据包。然后封装进TCP数据包，再封装进IP数据包，再封装进以太网数据包。")]),t._v(" "),v("p",[t._v("  如果以太网数据包过大，将会被拆分成多个数据包。")]),t._v(" "),v("p",[t._v("  最终数据包传递链路，以太网->交换机广播->网关->N个网关转发->目标机器->再一层一层拆包->解析到Http数据包->由tomcat封装http数据包到HttpServletRequest中->做业务处理->再响应出去->再次封装数据包->按原路径返回。")]),t._v(" "),v("p",[v("strong",[t._v("5、Http的各个版本")])]),t._v(" "),v("p",[v("strong",[t._v("  1、Http1.0")]),t._v("，默认是短连接，可以通过指定keep-alive来开启持久化连接。浏览器每次请求都要重新建立一次tcp连接，然后释放连接。")]),t._v(" "),v("p",[v("strong",[t._v("  2、Http1.1")]),t._v("，HTTP1.1默认支持长连接，浏览器打开一个网页之后，底层一直保持TCP连接，不会立马断开。之后加载css、js之类的请求，都会基于这个TCP连接。HTTP1.1还支持host头，也就可以支持虚拟主机，而且对断点续传有支持。")]),t._v(" "),v("p",[v("strong",[t._v("  3、Http2.0")]),t._v("，HTTP2.0支持多路复用，基于一个tcp连接并行发送多个请求以及接收响应，解决了http1.1对同一时间同一个域名的请求有限制的问题。二进制分帧，将传输数据拆分为更小的帧，提高了性能，实现低延迟高吞吐。")]),t._v(" "),v("p",[v("strong",[t._v("6、HTTP的长连接是什么？")])]),t._v(" "),v("p",[t._v("  HTTP本身没有长、短连接一说，"),v("strong",[t._v("关键在于底层的TCP是什么连接")]),t._v("。")]),t._v(" "),v("p",[t._v("  HTTP1.0的底层TCP是短连接，网页发起的一个请求，都要先经过三次握手，发送请求，获取响应，然后四次挥手断开连接。")]),t._v(" "),v("p",[t._v("  HTTP1.1的底层TCP是长连接。三次握手建立连接之后，无论多少请求都是走一个TCP连接的，然后四次挥手断开连接。长连接的方案在业内其实不常用，只是在一些特殊的场景下需要用长连接。")]),t._v(" "),v("h3",{attrs:{id:"tcp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp协议"}},[t._v("#")]),t._v(" TCP协议")]),t._v(" "),v("p",[t._v("  传输控制协议（TCP）是Internet一个重要的传输层协议。TCP提供面向连接、可靠、有序、"),v("strong",[t._v("字节流")]),t._v("传输服务，应用程序在使用TCP之前，必须先建立TCP连接。")]),t._v(" "),v("p",[v("strong",[t._v("  1、TCP包头示意图如下")]),t._v("：")]),t._v(" "),v("img",{attrs:{src:"/网络/TCP数据报文.png"}}),t._v(" "),v("p",[v("strong",[t._v("  源端口号")]),t._v("和"),v("strong",[t._v("目标端口号")]),t._v("是必不可少的，不然数据就不知道该发给哪个应用了。")]),t._v(" "),v("p",[v("strong",[t._v("  序号")]),t._v("是为了解决包乱序的问题。")]),t._v(" "),v("p",[v("strong",[t._v("  确认号")]),t._v("是为了确认发出去对方是否有收到，不然会重发直到送达，为了解决不丢包的问题。")]),t._v(" "),v("p",[v("strong",[t._v("  状态位")]),t._v("，例如 "),v("code",[t._v("SYN")]),t._v(" 是发起一个连接，"),v("code",[t._v("ACK")]),t._v(" 是回复，"),v("code",[t._v("RST")]),t._v(" 是重新连接，"),v("code",[t._v("FIN")]),t._v(" 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。")]),t._v(" "),v("p",[v("strong",[t._v("  窗口大小")]),t._v("，TCP要做流量控制，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力。")]),t._v(" "),v("p",[v("strong",[t._v("2、如何建立TCP连接")]),t._v("？")]),t._v(" "),v("p",[t._v("  这就叫提到大名鼎鼎的面试真题，什么是"),v("strong",[t._v("三次握手")]),t._v("。")]),t._v(" "),v("p",[t._v("  TCP三次握手建立连接，本质来说是在发送数据之前，先要检测一下网络是否通畅。TCP建立连接如下图所示。")]),t._v(" "),v("img",{attrs:{src:"/网络/TCP建立连接.png",width:"650px"}}),t._v(" "),v("p",[v("strong",[t._v("3、如何断开TCP连接")]),t._v("？")]),t._v(" "),v("p",[t._v("  这就叫提到大名鼎鼎的面试真题，什么是"),v("strong",[t._v("四次挥手")]),t._v("。")]),t._v(" "),v("p",[t._v("  TCP四次挥手断开连接，本质来说是在发送数据之前，先要检测一下网络是否通畅。")]),t._v(" "),v("p",[v("strong",[t._v("4、为什么TCP建立连接两次不行")]),t._v("？")]),t._v(" "),v("p",[t._v("  当客户端第一次与服务端建立连接时，不知道什么原因迟迟建立不了。于是客户端重新发送了第一次握手，服务端响应了第二次握手准备进行通信，并成功返回响应，并关闭了连接。")]),t._v(" "),v("p",[t._v("  后来第一次发送的连接居然到达了服务端，服务端响应第二次握手并开辟了资源准备与客户端进行通信。客户端收到第二次握手之后没有任何表示，客户端认为请求已经结束了，服务端也在等着客户端的请求，浪费了服务端的资源。")]),t._v(" "),v("p",[v("strong",[t._v("  如果说是三次握手")]),t._v("，客户端发现第二次握手不是我需要的，因为这个连接之前已经处理过了。客户端遵循三次握手的过程，要求"),v("strong",[t._v("释放资源（复位连接")]),t._v("）。")]),t._v(" "),v("img",{attrs:{src:"/网络/两次TCP.png"}}),t._v(" "),v("p",[v("strong",[t._v("  为什么TCP建立连接四次不行")]),t._v("？三次握手已经足够了，更多的握手只是浪费资源。")]),t._v(" "),v("p",[t._v("  总结三次握手，"),v("strong",[t._v("目的是保证双方都有发送和接收的能力")]),t._v("。")]),t._v(" "),v("p",[v("strong",[t._v("5、四次挥手流程")])]),t._v(" "),v("p",[t._v("  因为TCP连接是全双工的网络协议，允许通信的双方同时进行数据的收发，同样也允许收发两个方向的连接被独立关闭，以避免client数据发送完毕， 向server发送FIN关闭连接，而server还有发送到client的数据没有发送完毕的情况。 所以关闭TCP连接需要进行四次握手，每次关闭一个方向上的连接需要FIN和ACK两次握手。")]),t._v(" "),v("p",[t._v("  客户端与服务端都处于"),v("code",[t._v("established")]),t._v("状态。")]),t._v(" "),v("p",[t._v("  （1）客户端向服务端发送FIN请求，请求释放连接。随后客户端进入"),v("code",[t._v("FIN_WAIT_1")]),t._v("状态。")]),t._v(" "),v("p",[t._v("  （2）服务端收到客户端的FIN请求，响应ACK给客户端。随后服务端进入"),v("code",[t._v("CLOSE_WAIT")]),t._v("状态。")]),t._v(" "),v("p",[t._v("  （3）客户端收到服务端的ACK响应。随后客户端进入"),v("code",[t._v("FIN_WAIT_2")]),t._v("状态。")]),t._v(" "),v("p",[t._v("  （4）服务端处理完请求之后，向客户端发送FIN请求。随后服务端进入"),v("code",[t._v("LAST_ACK")]),t._v("状态。")]),t._v(" "),v("p",[t._v("  （5）客户端收到服务端的FIN请求，响应ACK给服务端。随后客户端进入"),v("code",[t._v("TIME_WAIT")]),t._v("状态，此时需要等待2MSL。")]),t._v(" "),v("p",[t._v("  （6）服务端收到客户端的ACK响应。随后服务端进入"),v("code",[t._v("CLOSED")]),t._v("状态，关闭了连接。")]),t._v(" "),v("p",[t._v("  MSL是数据包单向传输的最大持续时间。服务端在1MSL内，没有收到客户端的ACK响应，则继续发送FIN请求给客户端。客户端收到请求后，重置"),v("code",[t._v("TIME_WAIT")]),t._v("状态的时间，发送ACK响应给服务端。")]),t._v(" "),v("p",[t._v("  2MSL是为了保证被关闭连接的一方能够正确的关闭连接。")]),t._v(" "),v("h3",{attrs:{id:"udp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#udp协议"}},[t._v("#")]),t._v(" UDP协议")]),t._v(" "),v("p",[t._v("  用户数据报协议UDP是Internet传输层协议。提供无连接、不可靠、数据报尽力传输服务。")]),t._v(" "),v("p",[t._v("  数据报文如下图所示。")]),t._v(" "),v("img",{attrs:{src:"/网络/UDP数据报文.png"}}),t._v(" "),v("p",[v("strong",[t._v("1、UDP协议的特点")])]),t._v(" "),v("p",[t._v("  应用进程更容易控制发送什么数据以及何时发送。无需建立连接。无连接状态。首部开销小。")]),t._v(" "),v("p",[t._v("  对于数据可靠性要求不高，比如音视频聊天，视频卡顿一下、模糊一下是能够接收的。或者物联网的设备日志上报，偶尔丢一个影响不大。")]),t._v(" "),v("p",[v("strong",[t._v("2、TCP与UDP的比较")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("TCP")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("UDP")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("面向连接")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("无连接")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("提供可靠性保证")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("不可靠")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("慢")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("快")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("资源占用多")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("资源占用少")])])])])])}),[],!1,null,null,null);_.default=s.exports}}]);