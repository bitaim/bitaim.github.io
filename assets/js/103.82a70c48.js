(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{385:function(e,_,r){"use strict";r.r(_);var t=r(14),s=Object(t.a)({},(function(){var e=this,_=e.$createElement,r=e._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h4",{attrs:{id:"读未提交原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#读未提交原理"}},[e._v("#")]),e._v(" 读未提交原理")]),e._v(" "),r("p",[e._v("  在读未提交隔离级别下，存在行锁。但是读取数据时，每次读取的都是存储引擎中的"),r("strong",[e._v("最新数据")]),e._v("。也就是出现了脏读的问题。")]),e._v(" "),r("h4",{attrs:{id:"读已提交原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#读已提交原理"}},[e._v("#")]),e._v(" 读已提交原理")]),e._v(" "),r("p",[e._v("  为了解决脏读的问题，引入了MVCC（Multiversion Concurrency Control）多版本并发控制。\n"),r("strong",[e._v("MVCC只在读已提交和可重复读两个隔离级别下工作")]),e._v("。MVCC依赖于隐藏字段、Read View、Undo log实现。")]),e._v(" "),r("p",[r("strong",[e._v("1、一致性视图 ReadView")])]),e._v(" "),r("p",[e._v("  一致性视图也被称为快照。ReadView是一种数据结构，主要包含以下几部分。")]),e._v(" "),r("p",[e._v("  （1）trx_ids。负责存储未提交的事务id。")]),e._v(" "),r("p",[e._v("  （2）min_trx_id。指 trx_ids 中最小的事务id。")]),e._v(" "),r("p",[e._v("  （3）max_trx_id。系统中生成过的事务 ID最大值 + 1。")]),e._v(" "),r("p",[e._v("  （4）creator_trx_id。存储当前事务的id。")]),e._v(" "),r("p",[e._v("  在"),r("strong",[e._v("RC隔离级别")]),e._v("下，事务开启之后，每次执行select语句，都会重新创建一个快照。")]),e._v(" "),r("p",[e._v("  在"),r("strong",[e._v("RR隔离级别")]),e._v("下，事务开启之后，第一次执行select语句，才会创建一个快照。"),r("strong",[e._v("整个事务均使用该快照")]),e._v("。")]),e._v(" "),r("p",[r("strong",[e._v("2、可见性判断")])]),e._v(" "),r("p",[e._v("  如何判断记录行的版本是否可见。取要读取的记录行的版本记为"),r("code",[e._v("trx_id")]),e._v("。")]),e._v(" "),r("p",[e._v("  （1）如果 "),r("code",[e._v("trx_id")]),e._v(" < "),r("code",[e._v("min_trx_id")]),e._v("，代表该记录行在当前事务开启前就已经提交了，数据可见。")]),e._v(" "),r("p",[e._v("  （2）如果 "),r("code",[e._v("trx_id")]),e._v(" >= "),r("code",[e._v("max_trx_id")]),e._v("，代表该记录是由未来开启的事务修改的。不可见，跳到步骤4。")]),e._v(" "),r("p",[e._v("  （3）如果  "),r("code",[e._v("min_trx_id")]),e._v(" =< "),r("code",[e._v("trx_id")]),e._v(" < "),r("code",[e._v("max_trx_id")]),e._v("。判断是否是当前事务自己修改的，如果是那可见。如果不是判断是否在活跃的事务列表内，如果不在，那么可见。如果在，不可见，跳到步骤4。")]),e._v(" "),r("p",[e._v("  （4）通过该记录行的回滚指针，找到历史版本的数据，将事务id赋给 "),r("code",[e._v("trx_id")]),e._v("，回到步骤1重新开始判断。")]),e._v(" "),r("p",[e._v("  当查询数据时，首先要"),r("strong",[e._v("判断记录行的版本是否在 trx_ids 中，如果在那就看不到。并且只能看到小于等于当前事务的数据版本")]),e._v("。每次查询时，刷新快照，即可以看到已提交的数据。")]),e._v(" "),r("p",[r("strong",[e._v("3、简化的原理图")])]),e._v(" "),r("img",{attrs:{src:"/数据库/undolog.png"}}),e._v(" "),r("h4",{attrs:{id:"可重复读原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可重复读原理"}},[e._v("#")]),e._v(" 可重复读原理")]),e._v(" "),r("p",[e._v("  在开启事务后，通过第一次查询生成一致性视图，整个事务基于该视图来保证可重复读。")]),e._v(" "),r("p",[e._v("  快照读，通常使用的"),r("code",[e._v("select")]),e._v("语句，就是基于MVCC的快照读。")]),e._v(" "),r("p",[e._v("  当前读，能够读到所有提交的事务的最新值。比如"),r("code",[e._v("update")]),e._v("、"),r("code",[e._v("delete")]),e._v("语句都是当前读，特殊的有"),r("code",[e._v("select ... for update")]),e._v("也是当前读，这三种方式加的都是排它锁，会"),r("strong",[e._v("对扫描到的行加上行锁")]),e._v("。保证同一时刻只有一个事务可以操作该数据，保证数据的一致性。")]),e._v(" "),r("p",[r("strong",[e._v("  幻读是在当前读下才会出现，专指新插入的行")]),e._v("。为了解决幻读问题，可重复读隔离级别下引入了"),r("strong",[e._v("间隙锁")]),e._v("。"),r("strong",[e._v("间隙锁主要解决了两次当前读的可重复读问题")]),e._v("。")]),e._v(" "),r("p",[e._v("  行锁只能锁住扫描到的行，却无法锁住插入操作。因此使用间隙锁锁住了扫描到的行之间间隙，来阻止插入操作。")]),e._v(" "),r("p",[r("strong",[e._v("1、间隙锁实验")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 查看系统隔离级别\nselect @@global.tx_isolation;\n// 设置系统隔离级别\nset global transaction isolation level repeatable read;\n// 开启事务并获取一致性视图\nstart transaction with consistent snapshot;\n// 开启事务，提交事务，回滚事务\nbegin;commit;rollback;\n\n\n\n现有主键 1、7、15对应的三条数据\n\n（1）主键索引存在。\n\nselect * from user where user_id = 7 for update; // 对记录7加行锁。\n\nselect * from user where user_id > 7 for update; // 添加间隙锁(7,15)，(15,+)，对记录15加行锁。\n\nselect * from user where user_id >= 7 for update; // 添加间隙锁(7,15)，(15,+)，对记录7，记录15加行锁。\n\n（2）主键索引不存在。\n\nselect * from user where user_id = 5 for update; // 添加间隙锁(1,7)\n\nselect * from user where user_id > 5 for update; // 添加间隙锁(1,7)，(7,15)，(15,+)，对记录7，记录15加行锁。\n\nselect * from user where user_id >= 5 for update; // 添加间隙锁(1,7)，(7,15)，(15,+)，对记录7，记录15加行锁。\n\n（3）唯一索引存在。\n\nselect * from user where id_card = 'aaa' for update; // id_card唯一索引将 aaa 加锁，此时另一条aaa的数据时，会被阻塞，而不是报重复。\n\n（5）普通索引存在。\n\n有三个班级，一班，七班，十五班。\n\nselect * from user where class_id = 7 for update; // 首先要锁住7班的所有行（主键索引），然后对班级索引加间隙锁。添加间隙锁[1，15)。\n\nselect * from user where class_id > 7 for update; // 首先要锁住15班的所有行（主键索引），然后对班级索引加间隙锁。添加间隙锁[7,15)，[15,++)\n\nselect * from user where class_id >= 7 for update; // 首先要锁住7班，15班的所有行（主键索引），然后对班级索引加间隙锁。添加间隙锁[1,7)，[7,15)，[15,++)\n\n（6）普通索引不存在。\n\n有三个班级，一班，七班，十五班。\n\nselect * from user where class_id = 5 for update; // 对班级索引加间隙锁。添加间隙锁[1，7)。\n\nselect * from user where class_id > 5 for update; // 首先要锁住7班，15班的所有行（主键索引），然后对班级索引加间隙锁。添加间隙锁[1,7)，[7,15)，[15,++)\n\nselect * from user where class_id >= 5 for update; // 首先要锁住7班，15班的所有行（主键索引），然后对班级索引加间隙锁。添加间隙锁[1,7)，[7,15)，[15,++)\n\n")])])])])}),[],!1,null,null,null);_.default=s.exports}}]);