(window.webpackJsonp=window.webpackJsonp||[]).push([[199],{481:function(t,s,e){"use strict";e.r(s);var a=e(14),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"缓存设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存设计"}},[t._v("#")]),t._v(" 缓存设计")]),t._v(" "),e("p",[t._v("  京东和淘宝的页面是通过一种动态技术生成的html静态页面。无须经过后台服务器，因此没有性能损耗，只需要利用CDN加速即可。")]),t._v(" "),e("p",[t._v("  大部分网站的页面都是动态页面，页面上显示的数据都需要从后台服务器获取然后进行渲染，随时要与后台进行交互。比如发布一条招聘信息，就需要立即显示在主页上。")]),t._v(" "),e("p",[t._v("  而缓存不可避免的问题是可能有短暂的数据不一致的情况。如果对数据的实时性要求不高，可以采用异步的方式更新缓存。这样做同时解决了缓存穿透和缓存击穿的问题。")]),t._v(" "),e("p",[t._v("  为了维护数据库和缓存数据一致性的问题。采用延迟双删的策略，首先更新数据库，然后删除缓存，延迟一定事件再一次删除缓存。避免在高并发读场景下，写入脏缓存的问题，但是这种概率其实不高。")]),t._v(" "),e("h2",{attrs:{id:"多级缓存设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多级缓存设计"}},[t._v("#")]),t._v(" 多级缓存设计")]),t._v(" "),e("p",[t._v("  Redis集群是具体数据库最近的一层缓存，其数据也是较新的。在Redis集群获取数据时，同时将数据更新到本地缓存。当客户端获取数据时，优先走Redis集群，当Redis集群获取超时时，走本地缓存获取数据，避免请求击溃数据库。")])])}),[],!1,null,null,null);s.default=r.exports}}]);