(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{297:function(_,e,v){"use strict";v.r(e);var t=v(0),s=Object(t.a)({},(function(){var _=this,e=_.$createElement,v=_._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"分布式锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[_._v("#")]),_._v(" 分布式锁")]),_._v(" "),v("h4",{attrs:{id:"_1、锁丢失"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、锁丢失"}},[_._v("#")]),_._v(" 1、锁丢失")]),_._v(" "),v("p",[_._v("  Redis在单节点的情况下，不存在锁丢失的问题。")]),_._v(" "),v("p",[_._v("  Redis在主从架构下，存在锁丢失的问题。因为主从之间同步是异步的，如果在主节点加锁成功后，指令还没有同步到从节点。此时主节点宕机，从节点被提升为主节点。那么新的主节点上并没有锁的数据，这就是锁丢失，此时其他客户端可以加锁成功。"),v("strong",[_._v("发生了同一时间下，多个客户端同时获得锁的情况")]),_._v("。")]),_._v(" "),v("p",[_._v("  由于redis的主从架构是AP模型，保证了数据最终一致性，可能会导致锁丢失的情况。那么来看一下强一致性的分布式锁方案。")]),_._v(" "),v("h4",{attrs:{id:"_2、zookeeper、etcd"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、zookeeper、etcd"}},[_._v("#")]),_._v(" 2、zookeeper、etcd")]),_._v(" "),v("p",[_._v("  zookeeper采取zab协议，etcd采取raft协议（协议不了解，有时间学习一下）。")]),_._v(" "),v("p",[_._v("  zookeeper做分布式锁，利用了其"),v("strong",[_._v("临时顺序节点")]),_._v("的特性，但需要做写同步，所以其性能较差。etcd性能比zookeeper稍好。")]),_._v(" "),v("p",[_._v("  在互联网的应用中，其实不太关注数据的时效性，对于强一致性要求不是特别高，保证数据最终一致性即可。"),v("strong",[_._v("90%的场景都是使用Redis做分布式锁")]),_._v("。")]),_._v(" "),v("h4",{attrs:{id:"_3、redlock方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、redlock方案"}},[_._v("#")]),_._v(" 3、RedLock方案")]),_._v(" "),v("p",[_._v("  RedLock是Redis官方提供的方案，但在实际应用中使用的不多。")]),_._v(" "),v("p",[_._v("  RedLock的概念下需要至少奇数个Master主节点，比如3个。多个主节点之间相互独立，彼此之间不存在主从同步和数据赋值。")]),_._v(" "),v("p",[_._v("  如果在超过半数的机器上可以获取锁成功，则获取分布式锁成功。降级了多个客户端获取到锁的概率。")]),_._v(" "),v("p",[_._v("  因为需要部署多个节点，"),v("strong",[_._v("使用的资源（服务器）比较多，成本太大")]),_._v("。")]),_._v(" "),v("p",[_._v("  分布式锁的应用场景一般都是在高并发的情况下，因为需要对多个节点执行加锁和解锁命令，所以这种方式"),v("strong",[_._v("对性能的影响比较大")]),_._v("。")]),_._v(" "),v("h4",{attrs:{id:"_4、redisson"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、redisson"}},[_._v("#")]),_._v(" 4、Redisson")]),_._v(" "),v("p",[_._v("  Redisson方案是目前最常用的分布式锁方案，支持单机、主从、哨兵、集群的不同架构。")]),_._v(" "),v("p",[_._v("  底层通过"),v("strong",[_._v("lua脚本")]),_._v("对"),v("strong",[_._v("获取分布式锁，移除分布式锁")]),_._v("进行了封装，保证了其原子性。同时"),v("strong",[_._v("实现了可重入加锁")]),_._v("，lua脚本采用的是"),v("strong",[_._v("hset")]),_._v("的数据结构，可以记录获取锁的次数。并通过看门狗机制自动对分布式锁续期，看门狗每隔10秒去检查以下锁是否还被当前客户端持有，如果持有，则对key续期。")]),_._v(" "),v("p",[_._v("  如果采取了Redis集群架构，就有可能发生"),v("strong",[_._v("锁丢失")]),_._v("的问题。场景是某一个客户端成功在主节点上加锁成功，主节点还没有来得及同步到从节点就宕机了。任意一个从节点升级为主节点，锁就丢失了。这时另外一个客户端又可以获取到分布式锁，导致同一时刻出现多个客户端加锁成功的问题。这个问题很难解决，可能需要修改redis源码，保证加锁时必须主节点和从节点同时写成功才是加锁成功。")]),_._v(" "),v("h4",{attrs:{id:"_5、分布式锁的演化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、分布式锁的演化"}},[_._v("#")]),_._v(" 5、分布式锁的演化")]),_._v(" "),v("p",[_._v("  （1）利用redis的setnx特性，不存在时才可以设置成功。并配合expire命令，对锁设置过期时间，避免客户端意外宕机，锁无法被释放的问题。客户端在执行时，这是两条命令，没有保证原子性，无法保证锁百分百被添加过期时间。")]),_._v(" "),v("p",[_._v("  （2）利用redis的setnx ex命令，将获取锁和设置过期时间变成了一条原子命令。")]),_._v(" "),v("p",[_._v("  （3）如果客户端A获取分布式锁成功，但执行业务时很慢，分布式锁自动过期而被释放。此时客户端B就可以成功获取到分布式锁，"),v("strong",[_._v("此时出现多个客户端获取到锁的情况")]),_._v("。客户端A执行完毕调用del命令释放锁，结果"),v("strong",[_._v("客户端A释放了客户端B的锁，导致客户端C又可以获取锁")]),_._v("，这就乱套了。")]),_._v(" "),v("p",[_._v("  （4）因此这里就需要"),v("strong",[_._v("分布式锁的续期方案")]),_._v("，而redisson中使用看门狗替我们实现了这一逻辑。对于释放分布式锁，就需要客户端在"),v("strong",[_._v("获取分布式锁成功时，在value值中记录一个唯一值，释放锁时进行判断")]),_._v("。当前分布式锁的唯一值是否与我的相同，相同则释放。不同就不释放，避免释放掉其他客户端的锁。")])])}),[],!1,null,null,null);e.default=s.exports}}]);