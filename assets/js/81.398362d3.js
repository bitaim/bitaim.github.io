(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{281:function(v,_,t){"use strict";t.r(_);var s=t(0),o=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[v._v("#")]),v._v(" 锁")]),v._v(" "),t("p",[v._v("  数据库锁设计的初衷是处理并发问题，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。")]),v._v(" "),t("h2",{attrs:{id:"全局锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[v._v("#")]),v._v(" 全局锁")]),v._v(" "),t("p",[v._v("  全局锁是"),t("strong",[v._v("对整个数据库实例加锁")]),v._v("，实例中的所有数据库都被锁定。可以通过命令"),t("code",[v._v("Flush tables with read lock;")]),v._v("来加一个全局读锁，让整个数据库处于只读状态。"),t("strong",[v._v("全局锁的典型使用场景是，做全库逻辑备份")]),v._v("。")]),v._v(" "),t("p",[v._v("  加全局读锁的方式是很危险的。如果在主库备份，那么业务就必须全部停止。如果在从库备份，那么就无法同步binlog，导致主从延迟。")]),v._v(" "),t("p",[t("strong",[v._v("1、InnoDB存储引擎备份数据")])]),v._v(" "),t("p",[v._v("  对于InnoDB存储引擎，使用MySQL自带的逻辑备份工具是"),t("code",[v._v("mysqldump")]),v._v("，常用的指令是"),t("code",[v._v("mysqldump -h主机 -P端口 -u用户名 -p密码 --database 数据库名 > /usr/local/bak/user.sql")]),v._v("。参数"),t("code",[v._v("–single-transaction（待研究）")]),v._v("在备份整个库的数据时，会启动看那个一个事务来确保拿到一个一致性视图，由于MVCC的支持，备份的过程中数据是可以正常更新的。")]),v._v(" "),t("p",[t("strong",[v._v("2、MyISAM存储引擎备份数据")])]),v._v(" "),t("p",[v._v("  对于MyISAM这种不支持事务的引擎，就必须要使用"),t("code",[v._v("Flush tables with read lock")]),v._v("命令了。这也是DBA要求业务开发人员"),t("strong",[v._v("使用InnoDB替代MyISAM的原因之一")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"表级锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#表级锁"}},[v._v("#")]),v._v(" 表级锁")]),v._v(" "),t("p",[v._v("  表级别的锁有两种，一种是表锁，一种是元数据锁（MDL）。")]),v._v(" "),t("p",[v._v("  表锁的语法是"),t("code",[v._v("lock tables … read/write")]),v._v("。表锁一般是在数据库引擎不支持行锁的时候才会被用到的。")]),v._v(" "),t("p",[t("strong",[v._v("  元数据锁")]),v._v("：不需要显示使用，当访问一个表的时候会自动加上。")]),v._v(" "),t("p",[v._v("  当对一个表做增删改查操作时，加MDL读锁。当要对表做结构变更时，加MDL写锁。读锁之间不互斥，读写、写写之间互斥。因此有线程在进行增删改查操作时，不允许修改表结构。在一时间下，只允许一个线程修改表结构，并且修改表结构时不允许进行增删改查操作。")]),v._v(" "),t("p",[t("strong",[v._v("  对一个表结构进行修改，或者加索引，需要扫描全表的数据")]),v._v("。在对大表操作时，要格外小心，以免对线程服务造成影响。即使是小表，操作不慎，也会出问题。")]),v._v(" "),t("p",[v._v("  事务A开始事务，去查询表t数据。事务B开启事务，去查询表t数据。事务C开始事务，去修改表结构，此时被阻塞，因为前面还有两个读锁。事务D开始事务，去查询表t数据 ，会被事务C阻塞。此后的增删改查事务都会被阻塞住。如果对表t的事务比较频繁，那么很快该库的线程就会爆满。")]),v._v(" "),t("h2",{attrs:{id:"行锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行锁"}},[v._v("#")]),v._v(" 行锁")]),v._v(" "),t("p",[v._v("  行锁是由存储引擎实现的。MyISAM就不支持行锁，这也是"),t("strong",[v._v("MyISAM被InnoDB替代的重要原因之一")]),v._v("。")]),v._v(" "),t("p",[v._v("  在InnoDB事务中，行锁在需要时加上，在"),t("strong",[v._v("事务提交时才会释放行锁")]),v._v("。"),t("strong",[v._v("如果事务中需要锁多个行，要把可能造成锁冲突、最可能影响并发的锁尽量往后放。最大程度地减少了事务之间的锁等待，提升并发度")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("  死锁")]),v._v("：当并发系统中不同线程循环依赖资源，涉及的线程都在等待别的线程释放资源，就出现了死锁。死锁通常有两种策略：")]),v._v(" "),t("p",[v._v("  （1）线程进入等待直到超时。超时时间通过参数"),t("code",[v._v("innodb_lock_wait_timeout")]),v._v("控制，默认是50秒。")]),v._v(" "),t("p",[v._v("  （2）发起死锁检索，主动回滚死锁链条中的某一个事务，让其他事务得以执行。")]),v._v(" "),t("p",[v._v("  正常情况下还是要"),t("strong",[v._v("采用第二种方案")]),v._v("。"),t("code",[v._v("innodb_deadlock_detect")]),v._v("参数是"),t("strong",[v._v("默认打开死锁检测")]),v._v("的。但是死锁检测也是有负担的。")]),v._v(" "),t("p",[v._v("  当事务来更新数据时，发现被阻塞，就要检测是否由于当前事务发生了死锁。如果有1000个线程同时更新同一行，这个死锁检测就是100万这个量级的。最终检测没有死锁，但这期间消耗了大量的CPU资源，会出现CPU利用率很高，但每秒却执行不了几个事务的问题。"),t("strong",[v._v("所以要考虑控制并发度的思路")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"间隙锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#间隙锁"}},[v._v("#")]),v._v(" 间隙锁")]),v._v(" "),t("p",[v._v("  间隙锁被使用在可重复读隔离级别下，为了解决两次当前读数据不一致的情况。详情请看下方的事务实现原理。")]),v._v(" "),t("h2",{attrs:{id:"乐观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁"}},[v._v("#")]),v._v(" 乐观锁")]),v._v(" "),t("p",[v._v("  乐观锁不是一种锁，而是一种解决问题的思路。")]),v._v(" "),t("p",[v._v("  下面是在并发场景下扣款的案例分析。")]),v._v(" "),t("p",[t("strong",[v._v("方案一")])]),v._v(" "),t("ol",[t("li",[v._v("首先查询账户余额，"),t("code",[v._v("SELECT 余额 FROM 钱包 WHERE id = #{钱包ID}")])]),v._v(" "),t("li",[v._v("计算扣款后的余额，记为v1。")]),v._v(" "),t("li",[v._v("最后修改余额"),t("code",[v._v("UPDATE 钱包 SET 余额 = #{v1} WHERE id = #{钱包ID}")])])]),v._v(" "),t("p",[t("strong",[v._v("  存在的问题")]),v._v("：当出现并行事务时，会出现数据错误问题。比如事务1和事务2同时更新一个钱包的余额，事务1查询账户余额为100元，事务2查询账户余额也为100元，两个事务分别计算后的余额为20元和80元，最终结果以最后提交的事务为准，导致余额数据最终错误。")]),v._v(" "),t("p",[t("strong",[v._v("方案二")])]),v._v(" "),t("p",[v._v("  悲观锁，引入Redis或者zookeeper，使用"),t("strong",[v._v("分布式锁")]),v._v("的方案，保证同一时间只能有一个请求能够成功。方案可行，但需要引入额外组件，还会降低吞吐量。")]),v._v(" "),t("p",[v._v("  乐观锁，数据库的乐观锁通过"),t("strong",[v._v("增加版本号")]),v._v("的方式来实现，与CAS原理相同。")]),v._v(" "),t("ol",[t("li",[v._v("查询账户余额，"),t("code",[v._v("SELECT 余额,版本号 FROM 钱包 WHERE id = #{钱包ID}")]),v._v("，并查出当前账户余额的版本号信息，记为version1，version1 + 1 记为 version2")]),v._v(" "),t("li",[v._v("计算扣款后的余额，记为v1。然后修改余额"),t("code",[v._v("UPDATE 钱包 SET 余额 = #{v1},version = #{version2} WHERE id = #{钱包ID} and version = #{version1}")])]),v._v(" "),t("li",[v._v("通过乐观锁的方式解决了并发事务扣款的问题。通过"),t("strong",[v._v("影响行数")]),v._v("即可确定是否扣款成功。")])])])}),[],!1,null,null,null);_.default=o.exports}}]);