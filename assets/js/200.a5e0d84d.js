(window.webpackJsonp=window.webpackJsonp||[]).push([[200],{482:function(v,_,t){"use strict";t.r(_);var n=t(14),s=Object(n.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[t("strong",[v._v("1、什么样的数据适合做缓存")]),v._v("？")]),v._v(" "),t("p",[v._v("  对于那些"),t("strong",[v._v("更新频率低，读取频率高")]),v._v("的数据，这些数据应该尽量被缓存。")]),v._v(" "),t("p",[v._v("  对于数据经常变化的数据，并不适合做缓存。一方面会增加系统的复杂性（"),t("strong",[v._v("缓存与数据的一致性问题")]),v._v("），另一方面也会带来一定的不稳定性（缓存系统的维护）。")]),v._v(" "),t("p",[v._v("  在一些特殊场景下，可能需要将经常变动的数据进行缓存。比如在电商场景下，"),t("strong",[v._v("商品的库存实时显示")]),v._v("等。")]),v._v(" "),t("p",[t("strong",[v._v("2、为什么要使用缓存")]),v._v("？")]),v._v(" "),t("p",[v._v("  （1）缓存可以减少请求打到数据库上的机会，减轻数据库的压力。缓存可以保护数据库，保证系统整体的稳定性，可以用来抗高并发查询。")]),v._v(" "),t("p",[v._v("  （2）对于复杂的逻辑，缓存可以大大提升性能，使接口响应快，增大系统的吞吐量，用户的体验也好。")]),v._v(" "),t("p",[t("strong",[v._v("3、缓存与数据一致性问题")])]),v._v(" "),t("p",[v._v("  对于缓存数据，非常明确的一点是，是"),t("strong",[v._v("删除缓存而不是更新缓存。并且在考虑到高并发读的场景下，先更新数据库后删除缓存")]),v._v("。")]),v._v(" "),t("p",[v._v("  看下先删除缓存，再更新数据库的场景。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("（1）请求A删除缓存。\n（2）请求B查询缓存为空，于是查询到数据库旧值。\n（3）请求A更新数据库。\n（4）请求B将旧值写入缓存（**数据与缓存不一致**）。\n")])])]),t("p",[v._v("  再看下先更新数据库，还是再删除缓存呢。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("（1）请求B查询缓存为空，于是查询到缓存旧值。\n（2）请求A更新数据库。\n（3）请求A删除缓存。\n（4）请求B将旧值写入缓存（**数据与缓存不一致**）。\n")])])]),t("p",[v._v("  可以看到不管是哪种方式，都有概率出现数据与缓存不一致的情况。但是第二种情况出现的概率要小。")]),v._v(" "),t("p",[v._v("  那么再此基础上引入"),t("strong",[v._v("延时删除缓存")]),v._v("，整体的逻辑是"),t("strong",[v._v("先更新数据库，再删除缓存，再延时删除缓存一次")]),v._v("。保证没有脏缓存被写入。")]),v._v(" "),t("p",[v._v("  另外，"),t("strong",[v._v("延时删除缓存在数据库主从架构下")]),v._v("，也能发挥作用。因为主从之间同步数据有一定的延时，也有可能将旧数据写入缓存。")]),v._v(" "),t("p",[t("strong",[v._v("4、canal")])]),v._v(" "),t("p",[v._v("  当有请求更新数据库时，会同时生成binlog日志。canal基于mysql的协议将自己伪装成mysql的从节点，通过解析binlog日志去删除Redis缓存，做到缓存与数据的一致性是非常棒的方案，对代码的侵入性非常小。")]),v._v(" "),t("p",[v._v("  延时删除我们会通过异步的方式去执行，那如果删除缓存失败怎么办呢？删除失败进行重试并记录日志，必要时人为干预。")]),v._v(" "),t("p",[t("strong",[v._v("  数据与缓存做不到绝对一致性，但可以保证最终一致性")]),v._v("。")])])}),[],!1,null,null,null);_.default=s.exports}}]);