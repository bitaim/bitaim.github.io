(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{323:function(v,_,t){"use strict";t.r(_);var e=t(0),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"高速缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高速缓存"}},[v._v("#")]),v._v(" 高速缓存")]),v._v(" "),t("p",[v._v("  当开始写一些并发代码时，如果想要更好的理解原子性、可见性、原子性的问题，就必须要理解硬件级别的原理。这样才能对代码有更深刻的印象。")]),v._v(" "),t("p",[v._v("  在当今的科技下，处理器的性能是越来越高。CPU的性能远远大于内存，内存的性能又远远大于IO。"),t("strong",[v._v("CPU为了均衡与内存的速度差异，因此引入了高速缓存")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("p",[t("strong",[v._v("1、高速缓存的数据结构")])]),v._v(" "),t("p",[v._v("  高速缓存的底层数据结构是一个拉链散列表的结构。与"),t("code",[v._v("HashMap")]),v._v("的底层数据结构类似，底层是一个数组，每个位置拉出一个链表。如下图所示。")]),v._v(" "),t("img",{attrs:{src:"/操作系统/CPU高速缓存.png"}}),v._v(" "),t("p",[v._v("  缓存条目"),t("code",[v._v("cache entry")]),v._v("有三个重要属性。其中"),t("code",[v._v("tag")]),v._v("指向主内存中的一块内存地址。"),t("code",[v._v("flag")]),v._v("标识了当前数据的状态。"),t("code",[v._v("cache line")]),v._v("存储缓存的数据。")]),v._v(" "),t("p",[v._v("  处理器在读写高速缓存时，会根据变量名执行一个内存地址解码的操作，解析出"),t("code",[v._v("index")]),v._v("、"),t("code",[v._v("tag")]),v._v("和"),t("code",[v._v("offset")]),v._v("。"),t("code",[v._v("index")]),v._v("用于定位到具体的"),t("code",[v._v("bucket")]),v._v("，"),t("code",[v._v("tag")]),v._v("用于定位到具体的"),t("code",[v._v("cache entry")]),v._v("，"),t("code",[v._v("offset")]),v._v("用于定位"),t("code",[v._v("cache line")]),v._v("中变量的位置。")]),v._v(" "),t("p",[t("strong",[v._v("2、高速缓存如何加载数据")])]),v._v(" "),t("p",[v._v("  当CPU需要加载某个变量的数据时，CPU首先从距离最近的L1高速缓存中寻找数据，然后是L2、L3。如果未找到数据，则需要从其他处理器的高速缓存或者主内存中加载数据到当前处理器的高速缓存中。")]),v._v(" "),t("p",[v._v("  并且每次加载数据时，都会"),t("strong",[v._v("以块（缓存行）为单位")]),v._v("，为64字节，因此可以包含多个变量的数据。根据局部性访问规则，当访问一个数据时，有很大的概率会访问相邻的数据，因此加载一块数据可以减少CPU加载数据的次数。")]),v._v(" "),t("p",[t("strong",[v._v("3、缓存行对齐")])]),v._v(" "),t("p",[v._v("  CPU保证的缓存数据一致性是以缓存行为单位的。如果一个对象中有两个属性都被"),t("code",[v._v("volatile")]),v._v("修饰了，那么这两个属性大概率被分配到一个缓存行里。如果有两个线程分别对这两个属性进行修改，那么每次修改x就要通知其他处理器失效对应的缓存行，每次修改y也要通知其他处理器失效对应的缓存行，导致处理器每次都需要从主内存获取最新的数据，就利用不到CPU高速缓存了。")]),v._v(" "),t("p",[v._v("  为了避免这一问题，出现了一种缓存行对齐代码，如下所示。")]),v._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("long")]),v._v(" p1"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("p2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("p3"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("p4"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("p5"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("p6"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("p7"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// cache line padding")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("private")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("volatile")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("long")]),v._v(" cursor "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("long")]),v._v(" p8"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("p9"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("p10"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("p11"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("p12"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("p13"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("p14"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// cache line padding")]),v._v("\n")])])]),t("h3",{attrs:{id:"mesi协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mesi协议"}},[v._v("#")]),v._v(" MESI协议")]),v._v(" "),t("p",[v._v("  MESI协议保证数据一致性是以"),t("code",[v._v("cache entry")]),v._v("为单位的，也就是以缓存行为单位。")]),v._v(" "),t("p",[v._v("  MESI协议规定，多个处理器可以"),t("strong",[v._v("并发读取")]),v._v("一个共享变量的值。但是"),t("strong",[v._v("只有一个处理器可以执行对一个共享变量的写操作")]),v._v("。也就是"),t("strong",[v._v("并发读，互斥写")]),v._v("。")]),v._v(" "),t("p",[v._v("  MESI协议中规定缓存的数据有4种状态，分别是：")]),v._v(" "),t("p",[v._v("  （1）修改态（Modified）。当前的"),t("code",[v._v("cache entry")]),v._v("数据是有效的，并且该数据与内存中的值是不同的。该数据只能存在于一个处理器的高速缓存中。")]),v._v(" "),t("p",[v._v("  （2）专有态（Exclusive）。当前的"),t("code",[v._v("cache entry")]),v._v("数据是有效的，并且该数据与内存中的值是相同的。该数据只存在于一个处理器的高速缓存中。")]),v._v(" "),t("p",[v._v("  （3）共享态（Shared）。当前的"),t("code",[v._v("cache entry")]),v._v("数据是有效的，并且该数据与内存中的值是相同的。该数据在多个处理器的高速缓存中。")]),v._v(" "),t("p",[v._v("  （4）无效态（Invalid）。当前的"),t("code",[v._v("cache entry")]),v._v("数据是无效的，不能被使用。该数据可以在多个处理器的高速缓存中。")]),v._v(" "),t("p",[t("strong",[v._v("1、为什么需要MESI协议")])]),v._v(" "),t("p",[v._v("  每个处理器都有自己的高速缓存，可能会导致主内存中的一个变量在各个处理器的高速缓存中都有一个副本。一旦某个处理器修改了该变量的值，其他处理器是看不到最新的数据的。为了解决这一问题，因此引入了缓存一致性MESI协议。")]),v._v(" "),t("p",[v._v("  MESI协议规定，各个处理器在操作高速缓存数据时，都会"),t("strong",[v._v("向总线发送消息")]),v._v("。而各个处理器同时也会不停地"),t("strong",[v._v("从总线嗅探最新的消息")]),v._v("，通过总线传递的消息来保证各个处理器的数据的最终一致性。")]),v._v(" "),t("p",[t("strong",[v._v("2、基于MESI协议的读操作")])]),v._v(" "),t("p",[v._v("  当 处理器-0 要读取高速缓存中的数据时。")]),v._v(" "),t("p",[v._v("  （1）如果发现数据的缓存条目状态为M（修改）、E（独占）、S（共享），那么可以直接读取数据。因为这三种状态下，数据都是有效的。")]),v._v(" "),t("p",[v._v("  （2）如果发现数据的缓存条目状态为I（失效）。这时 处理器-0 会发送一条"),t("code",[v._v("read消息")]),v._v("到总线来读取有效的数据。这时缓存状态不为I（失效）的其他处理器或主内存（其他处理器缓存条目状态都为I时，才从主内存读）收到消息后需要回复"),t("code",[v._v("read response")]),v._v("消息，将有效的数据返回给 处理器-0。"),t("strong",[v._v("返回有效数据的处理器，如果缓存条目状态为M，则先将数据写入主内存，此时状态为E，然后再返回"),t("code",[v._v("read response")]),v._v("消息后，再将状态更新为S")]),v._v("。")]),v._v(" "),t("p",[v._v("  其他处理器的状态，有以下几种组合吧。"),t("code",[v._v("3S")]),v._v("，"),t("code",[v._v("1M,2I")]),v._v("，"),t("code",[v._v("1E,2I")]),v._v("，"),t("code",[v._v("3I")]),v._v("。")]),v._v(" "),t("p",[v._v("  这样 处理器-0 读取的永远是最新的数据，即使其他处理器对这个数据做了更改，也会获取到其他处理器最新的修改信息。")]),v._v(" "),t("p",[t("strong",[v._v("3、基于MESI协议的写操作")])]),v._v(" "),t("p",[v._v("  当 处理器-0 要对高速缓存中的数据进行写操作时。")]),v._v(" "),t("p",[v._v("  （1）如果发现数据的缓存条目状态为M（修改）、E（独占），那么处理器可以直接对高速缓存的数据执行写操作，完成后把缓存条目的状态置为M。")]),v._v(" "),t("p",[v._v("  （2）如果发现数据的缓存条目状态为S，则会先向总线发送"),t("code",[v._v("invalidate消息")]),v._v("，来通知其他处理器的高速缓存该缓存条目无效，来获取该缓存条目的独占权。当收到所有拥有该数据副本的处理器返回的"),t("code",[v._v("invalidate ack消息")]),v._v("后，才"),t("strong",[v._v("确认已获得该缓存条目的独占权（缓存状态置为E）")]),v._v("，将数据写入高速缓存，并把缓存条目状态更新为M。")]),v._v(" "),t("p",[v._v("  （3）如果发现数据的缓存条目状态为I，则会向总线发送"),t("code",[v._v("read invalidate消息")]),v._v("，先获取最新的数据，再通过"),t("code",[v._v("invaladate")]),v._v("来获取独占权。接收到消息的处理器将对应的缓存条目状态置为I。")]),v._v(" "),t("h3",{attrs:{id:"写缓冲器和无效队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写缓冲器和无效队列"}},[v._v("#")]),v._v(" 写缓冲器和无效队列")]),v._v(" "),t("p",[v._v("  MESI协议虽然解决了缓存一致性协议，但有一个性能缺陷。处理器每次写数据时，都需要等待其他处理器将对应的缓存条目失效，并接收它们返回的"),t("code",[v._v("read response")]),v._v("消息和"),t("code",[v._v("invalidate ack")]),v._v("消息后才可以执行写操作。这个过程是很耗费时间的。")]),v._v(" "),t("p",[v._v("  写缓冲器，是处理器内部一个容量比高速缓存还小的高速存储部件，每个存储器都有自身的写缓冲器。且一个处理器无法读取其他处理器的写缓冲器的内容。")]),v._v(" "),t("p",[t("strong",[v._v("1、优化后的写操作")])]),v._v(" "),t("p",[v._v("  （1）如果缓存条目的状态为M、E，则直接写入高速缓存。")]),v._v(" "),t("p",[v._v("  （2）如果缓存条目的状态为S，处理器将写操作写入写缓冲器，并发送"),t("code",[v._v("invalidate消息")]),v._v("到总线，不再等待响应消息。")]),v._v(" "),t("p",[v._v("  （3）如果缓存条目的状态为I，处理器将写操作写入写缓冲器，并发送"),t("code",[v._v("read invalidate消息")]),v._v("到总线，不再等待响应消息。")]),v._v(" "),t("p",[v._v("  当处理器将写操作写入写缓冲器后，则认为写操作已经完成。而实际上，当处理器接收到其他所有处理器回应的"),t("code",[v._v("read response消息")]),v._v("、"),t("code",[v._v("invalidate消息")]),v._v("后，处理器才会将写缓冲器中对应的写操作写入相应的缓存行。此时写操作才真正完成。")]),v._v(" "),t("p",[v._v("  当处理器接收到"),t("code",[v._v("invalidate消息")]),v._v("后，并不马上过期缓存条目。而是将消息存入无效队列，直接回复"),t("code",[v._v("invalidate ack")]),v._v("消息，从而减少执行写操作的处理器的等待时间。")]),v._v(" "),t("p",[v._v("  写操作让处理器在执行写操作时不需要再额外的等待，提高了处理器的指令执行效率。")]),v._v(" "),t("p",[t("strong",[v._v("2、优化后的读操作")])]),v._v(" "),t("p",[v._v("  引入写缓冲器后，处理器读取数据时。由于该数据的更新结果可能仍然停留在写缓冲器中，所以处理器会先从写缓冲器中寻找数据，再从高速缓存中寻找。")]),v._v(" "),t("h3",{attrs:{id:"引发的新问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引发的新问题"}},[v._v("#")]),v._v(" 引发的新问题")]),v._v(" "),t("p",[v._v("  由于MESI的高速缓存一致性是建立在强一致性的总线串行事务上的，而写缓冲器和失效队列将事务的强一致性弱化为了最终一致性，使得在一些临界点上全局的高速缓存中的数据并不是完全一致的。")]),v._v(" "),t("p",[t("strong",[v._v("1、引发的可见性问题")])]),v._v(" "),t("p",[v._v("  当 处理器-1 需要读取一个数据，有两种情况可能会导致可见性的问题。")]),v._v(" "),t("p",[v._v("  （1）如果 处理器-1 高速缓存未命中，则发送"),t("code",[v._v("read消息")]),v._v("到总线。如果 处理器-0 还没有将写缓冲器中的最新数据刷到高速缓存中，那么 处理器-0 返回给 处理器-1 的是旧数据。")]),v._v(" "),t("p",[v._v("  （2）如果 处理器-1 高速缓存命中，但 处理器-1 接收到"),t("code",[v._v("invalidate消息")]),v._v("被放入了无效队列。如果 处理器-1 还没有过期本地高速缓存，那么读取的是旧数据。")]),v._v(" "),t("p",[t("strong",[v._v("2、引发的有序性问题")])]),v._v(" "),t("p",[v._v("  有两个全局变量"),t("code",[v._v("number = 0")]),v._v("、"),t("code",[v._v("ready = false")]),v._v("，有两个处理器对其进行处理。")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("处理器0")]),v._v(" "),t("th",[v._v("处理器1")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("number = 10（step1）")]),v._v(" "),t("td")]),v._v(" "),t("tr",[t("td",[v._v("ready = true （step2）")]),v._v(" "),t("td")]),v._v(" "),t("tr",[t("td"),v._v(" "),t("td",[v._v("while(true) break（step3）")])]),v._v(" "),t("tr",[t("td"),v._v(" "),t("td",[v._v("System.out.println(number)（step4）")])])])]),v._v(" "),t("p",[v._v("  处理器-0 步骤1可能会直接写入写缓冲器，而步骤2可能直接写入高速缓存。")]),v._v(" "),t("p",[v._v("  处理器-1 步骤3可以读到到"),t("code",[v._v("ready")]),v._v("的最新数据，而步骤4还不能读取到"),t("code",[v._v("number")]),v._v("的最新数据。因此打印"),t("code",[v._v("number")]),v._v("值为0。")]),v._v(" "),t("p",[v._v("  在处理器1看来，步骤2是先于步骤1执行的。"),t("strong",[v._v("处理器-0的两个写操作发生了内存重排序")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("3、as-if-serial语义")])]),v._v(" "),t("p",[v._v("  有了上述铺垫，就可以更容易理解"),t("strong",[v._v("as-if-serial语义")]),v._v("了。")]),v._v(" "),t("p",[v._v("  不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。所以编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。")]),v._v(" "),t("p",[v._v("  如果在本线程内观察，所有操作都是有序的。如果在另一个线程中观察，所有的操作都是无序的。前半句是指线程内表现为串行语义，后半句是指指令重排序现象和工作内存主内存同步延迟现象。")]),v._v(" "),t("h3",{attrs:{id:"内存屏障"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障"}},[v._v("#")]),v._v(" 内存屏障")]),v._v(" "),t("p",[v._v("  内存屏障分为读屏障（Load屏障）和写屏障（Store屏障）两种，内存屏障以机器指令的形式进行工作。")]),v._v(" "),t("p",[v._v("  写屏障用于保证高速缓存"),t("strong",[v._v("写操作的强一致性")]),v._v("。当CPU执行写屏障指令时，当前处理器位于写屏障指令之前的写操作必须全部处理完毕（等待其他处理器的"),t("code",[v._v("invalidate ack消息")]),v._v("，然后将写缓冲器中的写操作刷到高速缓存），才可以继续向下执行命令。强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。")]),v._v(" "),t("p",[v._v("  读屏障用于保证高速缓存"),t("strong",[v._v("读操作的强一致性")]),v._v("。当CPU执行读屏障指令时，必须先将当前处于失效队列中的"),t("code",[v._v("invalidate消息")]),v._v("处理完毕（过期高速缓存中的数据），才可以继续向下执行命令。强制读取主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。")]),v._v(" "),t("p",[v._v("  在读操作前，加读屏障。在写操作后，加写屏障。也就是"),t("code",[v._v("volatile")]),v._v("的原理。读取前，清空无效队列，使能读取最新数据。写操作后，清空写缓冲器，使值的修改同步更新到高速缓存。来保证数据的可见性。")]),v._v(" "),t("p",[v._v("  通过添加内存屏障，保证了写写操作之间无法被重排序。就不可能在出现第一个写在写缓冲器，第二个写在高速缓存了。第二个写必须强制等待第一个写完毕后，才可以执行。因此保证了有序性。")])])}),[],!1,null,null,null);_.default=a.exports}}]);