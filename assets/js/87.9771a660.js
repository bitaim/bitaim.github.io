(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{286:function(t,e,_){"use strict";_.r(e);var r=_(0),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[t._v("#")]),t._v(" 事务")]),t._v(" "),_("p",[t._v("  在MySQL的InnoDB存储引擎下，支持了事务操作。")]),t._v(" "),_("p",[t._v("  在启动一个事务时，会向InnoDB的事务系统申请一个唯一的事务ID，事务系统保证按申请顺序严格递增的。")]),t._v(" "),_("p",[_("strong",[t._v("1、事务的特性")])]),t._v(" "),_("p",[t._v("  事务有四大特性ACID，分别是 原子性（Atomicity）、隔离性（Isolation）、持久性（Durability）、一致性（Consistency)。原子性，事务中的操作全部成功提交，或者全部失败回滚。隔离性，事务之间互不干扰。持久性，事务一旦完成数据不会丢失。")]),t._v(" "),_("p",[t._v("  保证了原子性，隔离性，持久性。即可以保证一致性。")]),t._v(" "),_("h2",{attrs:{id:"隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别"}},[t._v("#")]),t._v(" 隔离级别")]),t._v(" "),_("p",[t._v("  与事务最密切相关的一个属性就是"),_("strong",[t._v("隔离性 I")]),t._v("。使用不同的隔离级别，在事务中的表现也不相同。MySQL的隔离性下，包含4个隔离级别，分别是 读未提交、读已提交、可重复读、串行化。"),_("strong",[t._v("MySQL中的默认隔离级别是可重复读")]),t._v("。")]),t._v(" "),_("h4",{attrs:{id:"四大隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四大隔离级别"}},[t._v("#")]),t._v(" 四大隔离级别")]),t._v(" "),_("p",[t._v("  读未提交。一个事务可以读取到其他事务未提交的数据。")]),t._v(" "),_("p",[t._v("  读已提交。一个事务只可以读取到其他事务提交的数据。")]),t._v(" "),_("p",[t._v("  可重复读。一个事务在整个执行过程中，获取到的数据是相同的。")]),t._v(" "),_("p",[t._v("  串行化。事务之间互斥，需要串行化处理，性能极差。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("事务的隔离级别")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("存在的问题")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("解决的问题")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("Read uncommitted")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("脏读,不可重复度,幻读")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("Read committed")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("不可重复度,幻读")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("脏读")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("Repeatable read")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("幻读")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("脏读,不可重复度")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("Serializable")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("串行化,效率奇低")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("脏读,不可重复度,幻读")])])])]),t._v(" "),_("h4",{attrs:{id:"读未提交原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#读未提交原理"}},[t._v("#")]),t._v(" 读未提交原理")]),t._v(" "),_("p",[t._v("  在读未提交隔离级别下，存在行锁。但是读取数据时，每次读取的都是存储引擎中的"),_("strong",[t._v("最新数据")]),t._v("。也就是出现了脏读的问题。")]),t._v(" "),_("h4",{attrs:{id:"读已提交原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#读已提交原理"}},[t._v("#")]),t._v(" 读已提交原理")]),t._v(" "),_("p",[t._v("  为了解决脏读的问题，引入了MVCC（Multiversion Concurrency Control）多版本并发控制。"),_("strong",[t._v("MVCC只在读已提交和可重复读两个隔离级别下工作")]),t._v("。MVCC依赖于隐藏字段、Read View、Undo log实现。")]),t._v(" "),_("p",[_("strong",[t._v("1、一致性视图 ReadView")])]),t._v(" "),_("p",[t._v("  一致性视图也被称为快照。ReadView是一种数据结构，主要包含以下几部分。")]),t._v(" "),_("p",[t._v("  （1）trx_ids。负责存储未提交的事务id。")]),t._v(" "),_("p",[t._v("  （2）min_trx_id。指 trx_ids 中最小的事务id。")]),t._v(" "),_("p",[t._v("  （3）max_trx_id。系统中生成过的事务 ID最大值 + 1。")]),t._v(" "),_("p",[t._v("  （4）creator_trx_id。存储当前事务的id。")]),t._v(" "),_("p",[t._v("  在"),_("strong",[t._v("RC隔离级别")]),t._v("下，事务开启之后，每次执行select语句，都会重新创建一个快照。")]),t._v(" "),_("p",[t._v("  在"),_("strong",[t._v("RR隔离级别")]),t._v("下，事务开启之后，第一次执行select语句，才会创建一个快照。"),_("strong",[t._v("整个事务均使用该快照")]),t._v("。")]),t._v(" "),_("p",[_("strong",[t._v("2、可见性判断")])]),t._v(" "),_("p",[t._v("  如何判断记录行的版本是否可见。取要读取的记录行的版本记为"),_("code",[t._v("trx_id")]),t._v("。")]),t._v(" "),_("p",[t._v("  （1）如果 "),_("code",[t._v("trx_id")]),t._v(" < "),_("code",[t._v("min_trx_id")]),t._v("，代表该记录行在当前事务开启前就已经提交了，数据可见。")]),t._v(" "),_("p",[t._v("  （2）如果 "),_("code",[t._v("trx_id")]),t._v(" >= "),_("code",[t._v("max_trx_id")]),t._v("，代表该记录是由未来开启的事务修改的。不可见，跳到步骤4。")]),t._v(" "),_("p",[t._v("  （3）如果  "),_("code",[t._v("min_trx_id")]),t._v(" =< "),_("code",[t._v("trx_id")]),t._v(" < "),_("code",[t._v("max_trx_id")]),t._v("。判断是否是当前事务自己修改的，如果是那可见。如果不是判断是否在活跃的事务列表内，如果不在，那么可见。如果在，不可见，跳到步骤4。")]),t._v(" "),_("p",[t._v("  （4）通过该记录行的回滚指针，找到历史版本的数据，将事务id赋给 "),_("code",[t._v("trx_id")]),t._v("，回到步骤1重新开始判断。")]),t._v(" "),_("p",[t._v("  当查询数据时，首先要"),_("strong",[t._v("判断记录行的版本是否在 trx_ids 中，如果在那就看不到。并且只能看到小于等于当前事务的数据版本")]),t._v("。每次查询时，刷新快照，即可以看到已提交的数据。")]),t._v(" "),_("p",[_("strong",[t._v("3、简化的原理图")])]),t._v(" "),_("img",{attrs:{src:"/数据库/undolog.png"}}),t._v(" "),_("h4",{attrs:{id:"可重复读原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可重复读原理"}},[t._v("#")]),t._v(" 可重复读原理")]),t._v(" "),_("p",[t._v("  在开启事务后，通过第一次查询生成一致性视图，整个事务基于该视图来保证可重复读。")]),t._v(" "),_("p",[t._v("  快照读，通常使用的"),_("code",[t._v("select")]),t._v("语句，就是基于MVCC的快照读。")]),t._v(" "),_("p",[t._v("  当前读，能够读到所有提交的事务的最新值。比如"),_("code",[t._v("update")]),t._v("、"),_("code",[t._v("delete")]),t._v("语句都是当前读，特殊的有"),_("code",[t._v("select ... for update")]),t._v("也是当前读，这三种方式加的都是排它锁，会"),_("strong",[t._v("对扫描到的行加上行锁")]),t._v("。保证同一时刻只有一个事务可以操作该数据，保证数据的一致性。")]),t._v(" "),_("p",[_("strong",[t._v("  幻读是在当前读下才会出现，专指新插入的行")]),t._v("。为了解决幻读问题，可重复读隔离级别下引入了"),_("strong",[t._v("间隙锁")]),t._v("。"),_("strong",[t._v("间隙锁主要解决了两次当前读的可重复读问题")]),t._v("。")]),t._v(" "),_("p",[t._v("  行锁只能锁住扫描到的行，却无法锁住插入操作。因此使用间隙锁锁住了扫描到的行之间间隙，来阻止插入操作。")]),t._v(" "),_("p",[_("strong",[t._v("1、间隙锁实验")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("// 查看系统隔离级别\nselect @@global.tx_isolation;\n// 设置系统隔离级别\nset global transaction isolation level repeatable read;\n// 开启事务并获取一致性视图\nstart transaction with consistent snapshot;\n// 开启事务，提交事务，回滚事务\nbegin;commit;rollback;\n\n\n\n现有主键 1、7、15对应的三条数据\n\n（1）主键索引存在。\n\nselect * from user where user_id = 7 for update; // 对记录7加行锁。\n\nselect * from user where user_id > 7 for update; // 添加间隙锁(7,15)，(15,+)，对记录15加行锁。\n\nselect * from user where user_id >= 7 for update; // 添加间隙锁(7,15)，(15,+)，对记录7，记录15加行锁。\n\n（2）主键索引不存在。\n\nselect * from user where user_id = 5 for update; // 添加间隙锁(1,7)\n\nselect * from user where user_id > 5 for update; // 添加间隙锁(1,7)，(7,15)，(15,+)，对记录7，记录15加行锁。\n\nselect * from user where user_id >= 5 for update; // 添加间隙锁(1,7)，(7,15)，(15,+)，对记录7，记录15加行锁。\n\n（3）唯一索引存在。\n\nselect * from user where id_card = 'aaa' for update; // id_card唯一索引将 aaa 加锁，此时另一条aaa的数据时，会被阻塞，而不是报重复。\n\n（5）普通索引存在。\n\n有三个班级，一班，七班，十五班。\n\nselect * from user where class_id = 7 for update; // 首先要锁住7班的所有行（主键索引），然后对班级索引加间隙锁。添加间隙锁[1，15)。\n\nselect * from user where class_id > 7 for update; // 首先要锁住15班的所有行（主键索引），然后对班级索引加间隙锁。添加间隙锁[7,15)，[15,++)\n\nselect * from user where class_id >= 7 for update; // 首先要锁住7班，15班的所有行（主键索引），然后对班级索引加间隙锁。添加间隙锁[1,7)，[7,15)，[15,++)\n\n（6）普通索引不存在。\n\n有三个班级，一班，七班，十五班。\n\nselect * from user where class_id = 5 for update; // 对班级索引加间隙锁。添加间隙锁[1，7)。\n\nselect * from user where class_id > 5 for update; // 首先要锁住7班，15班的所有行（主键索引），然后对班级索引加间隙锁。添加间隙锁[1,7)，[7,15)，[15,++)\n\nselect * from user where class_id >= 5 for update; // 首先要锁住7班，15班的所有行（主键索引），然后对班级索引加间隙锁。添加间隙锁[1,7)，[7,15)，[15,++)\n\n")])])])])}),[],!1,null,null,null);e.default=v.exports}}]);