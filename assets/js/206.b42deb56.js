(window.webpackJsonp=window.webpackJsonp||[]).push([[206],{488:function(_,v,t){"use strict";t.r(v);var s=t(14),r=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"一次请求过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一次请求过程"}},[_._v("#")]),_._v(" 一次请求过程")]),_._v(" "),t("h3",{attrs:{id:"一、解析url"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、解析url"}},[_._v("#")]),_._v(" 一、解析URL")]),_._v(" "),t("p",[_._v("  当通过浏览器去访问百度主页，浏览器首先要对URL进行解析，由于"),t("code",[_._v("https://www.baidu.com")]),_._v("地址中没有路径名，默认去访问文件index.html，并生成HTTP请求消息（请求行、请求头、请求体）。详情参考"),t("a",{attrs:{href:"./02_Http协议.html"}},[_._v("HTTP协议")]),_._v("。")]),_._v(" "),t("p",[_._v("  生成HTTP消息后，需要"),t("strong",[_._v("DNS服务器")]),_._v("解析域名对应的真实IP地址，最终委托操作系统将消息发送给Web服务器。")]),_._v(" "),t("p",[t("strong",[_._v("1、域名解析流程")])]),_._v(" "),t("ul",[t("li",[_._v("1、客户端首先发出一个DNS请求，请求首先到达"),t("strong",[_._v("本地DNS服务器")]),_._v("。")]),_._v(" "),t("li",[_._v("2、如果能在本地DNS服务器找到域名对应的IP则直接返回IP地址，否则去询问"),t("strong",[_._v("根域名服务器")]),_._v("。")]),_._v(" "),t("li",[_._v("3、根域名服务器发现域名以"),t("code",[_._v(".com")]),_._v("结尾，则将"),t("code",[_._v(".com")]),_._v("顶级域名服务器地址返回，继续去询问"),t("code",[_._v(".com")]),t("strong",[_._v("顶级域名服务器")]),_._v("。")]),_._v(" "),t("li",[_._v("4、.com域名服务器将"),t("code",[_._v("www.baidu.com")]),_._v("的权威DNS服务器地址返回，继续询问"),t("strong",[_._v("权威DNS服务器")]),_._v("。")]),_._v(" "),t("li",[_._v("5、权威DNS服务器查看后将对应的IP地址返回本地DNS服务器。")]),_._v(" "),t("li",[_._v("6、本地DNS再将IP地址返回客户端，客户端和目标建立连接。")])]),_._v(" "),t("p",[_._v("  通过DNS服务器获取IP后，就可以把HTTP的传输工作交给操作系统的"),t("strong",[_._v("协议栈")]),_._v("。协议栈如下：")]),_._v(" "),t("img",{attrs:{src:"/网络/协议栈.jpg",width:"400px"}}),_._v(" "),t("p",[_._v("  应用程序（浏览器）通过调用socket库，来委托协议栈工作。协议栈的上半部分有两块，分别是"),t("strong",[_._v("负责收发数据的TCP和UDP协议")]),_._v("，会接受应用层的委托执行收发数据的操作。")]),_._v(" "),t("p",[_._v("  协议栈的下面一半是用"),t("strong",[_._v("IP协议控制网络包收发操作")]),_._v("，数据会被切分为一块块的网络包，将网络发送给目标服务器是由IP负责的。IP下的网卡驱动程序负责控制网卡硬件，网卡则负责完成实际的收发操作。")]),_._v(" "),t("p",[_._v("  IP中还包括"),t("strong",[_._v("ICMP协议")]),_._v("（用于告知网络包传送过程中产生的错误以及各种控制信息）和"),t("strong",[_._v("ARP协议")]),_._v("（用于根据 IP 地址查询相应的以太网 MAC 地址）。")]),_._v(" "),t("h3",{attrs:{id:"封装数据包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装数据包"}},[_._v("#")]),_._v(" 封装数据包")]),_._v(" "),t("p",[_._v("  HTTP是基于TCP协议传输的，详情参考"),t("a",{attrs:{href:"./04_TCP连接.html"}},[_._v("TCP协议")]),_._v("。TCP传输数据之前，需要"),t("strong",[_._v("三次握手")]),_._v("建立连接，目的是"),t("strong",[_._v("保证双方都有发送和接收的能力")]),_._v("。")]),_._v(" "),t("p",[_._v("  一个网络包的最大长度（IP头部 + TCP头部 + MSS），在以太网中一般为1500字节。如果HTTP消息比较长，就会被以MSS的长度进行拆分，拆分后的每一部分都会被加上TCP头信息，然后交给IP模块来发送数据。")]),_._v(" "),t("p",[_._v("  TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托"),t("strong",[_._v("IP模块")]),_._v("将数据封装成"),t("strong",[_._v("网络包（加上IP头）"),t("strong",[_._v("进行发送。在IP协议里面需要有")]),_._v("源地址IP")]),_._v("和"),t("strong",[_._v("目标地址IP（DNS解析返回的IP）")]),_._v("，因为HTTP是经过TCP传输的，所以在IP包头的"),t("strong",[_._v("协议号")]),_._v("为06（十六进制），表示协议为TCP。")]),_._v(" "),t("p",[t("strong",[_._v("  如何确认源IP地址")]),_._v("？")]),_._v(" "),t("p",[_._v("  当客户端存在多块网卡时，在填写源地址IP时，需要判断填写哪个地址，也就是判断使用哪一块网卡来发送包。此时就需要"),t("strong",[_._v("路由表规则")]),_._v("。")]),_._v(" "),t("p",[_._v("  用目标IP地址与路由表中每个条目的子网掩码进行与运算，找到与Destination相同的条目，同时也确定了发送方的MAC地址。如果Destination是0.0.0.0，表示为默认网关，所有的数据都需要发送到这个网关（GateWay的IP地址）。")]),_._v(" "),t("p",[_._v("  生成了IP头部后，接下来网络包还需要再IP头部前加上"),t("strong",[_._v("MAC头部")]),_._v("。MAC头部是以太网使用的头部，在MAC包头里需要"),t("strong",[_._v("发送方MAC地址")]),_._v("和"),t("strong",[_._v("接收方目标MAC地址")]),_._v("，用于"),t("strong",[_._v("两点之间的传输")]),_._v("。")]),_._v(" "),t("p",[_._v("  发送方的MAC地址已经确定，但是"),t("strong",[_._v("接收者")]),_._v("的MAC地址是不知道的。根据上一路由表的匹配，可以确认路由的IP地址，此时可以根据"),t("strong",[_._v("ARP协议")]),_._v("，ARP协议在以太网中以广播的形式，对以太网所有的设备询问，这个IP的MAC地址是谁啊，然后将MAC头部写入。操作系统在后续会把本次查询结果放到一块ARP缓存的内存空间中避免频繁广播，不过缓存的时间只有几分钟。最终封装成如下包：")]),_._v(" "),t("img",{attrs:{src:"/网络/Http数据包.png",width:"450px"}}),_._v(" "),t("p",[_._v("  在网络包传输的过程中，"),t("strong",[_._v("源IP地址和目标IP地址始终是不变的，一直变化的是MAC地址")]),_._v("，因为需要MAC地址在以太网内进行两个设备之间的包传输。")]),_._v(" "),t("p",[t("strong",[_._v("  出口网卡")])]),_._v(" "),t("p",[_._v("  IP生成的数据包只是存放在内存中的一串二进制数字信息，需要将数字信息转换为电信号。IP模块中的网卡驱动程序控制网卡完成这一操作，最终从网线发送出去。")]),_._v(" "),t("p",[_._v("  网卡驱动从IP模块获取到包之后，会将其复制到网卡内的缓存区中，接着会其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。起始帧分界符是一个用来表示包起始位置的标记，末尾的"),t("code",[_._v("FCS")]),_._v("（帧校验序列）用来检查包传输过程是否有损坏。")]),_._v(" "),t("p",[t("strong",[_._v("  交换机")])]),_._v(" "),t("p",[_._v("  交换机的设计是为了将网络包原样转发到目的地。交换机接收的包通常来自客户端、路由器，通常包的转发有以下3种方式。")]),_._v(" "),t("ul",[t("li",[_._v("1、客户端发出的包经交换机转发到路由器。")]),_._v(" "),t("li",[_._v("2、路由器的发出的包经交换机转发到下一个路由器。")]),_._v(" "),t("li",[_._v("3、路由器发出的包经路由器转发到目标机器。")])]),_._v(" "),t("p",[t("strong",[_._v("  交换机的包接受操作")]),_._v("。当电信号到达交换机的网线接口时，交换机中的模块将电信号转换为数字信号。开始对包末尾的FCS进行错误校验，通过就可以放入缓冲区。由于"),t("strong",[_._v("交换机的端口不具有MAC地址")]),_._v("，因此交换机的端口不核对接收方MAC地址，只要通过校验就接收。")]),_._v(" "),t("p",[_._v("  将包放入缓冲区后，就需要查询这个包的接收方MAC地址是否已经在交换机的MAC地址表中了。如果存在，就可以通过交换电路将包发送到相应的端口上。如果不存在，交换机无法判断把包转发到哪个端口，因此只能"),t("strong",[_._v("将网络包转发到除了源端口之外的所有端口，只有相应的接收者才接收包，而其他设备则会忽略这个包")]),_._v("。")]),_._v(" "),t("p",[_._v("  地址表中找不到接收者的MAC地址的原因？第一，可能是因为该MAC地址的设备还没有向交换机发送过包。第二，可能该MAC地址的设备很长时间没有工作而被删除了。")]),_._v(" "),t("p",[t("strong",[_._v("  路由器")])]),_._v(" "),t("p",[_._v("  网络包经过交换机到达了路由器，并在此被转发到下一个路由器或目标设备。")]),_._v(" "),t("p",[t("strong",[_._v("  路由器的包接收操作")]),_._v("，电信号到达路由器的网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的FCS进行错误校验。如果没问题，则检查MAC头部的接收方地址是不是自己，如果是则存入缓冲区中，否则就弃包。完成包接收之后，路由器就会"),t("strong",[_._v("去掉网络包开头的MAC头部")]),_._v("。MAC头部的作用就是将包送达路由器，其中的接收方MAC地址就是路由器端口的MAC地址。因此，当包到达路由器之后，MAC头部的任务就完成了，于是MAC头部就会被丢弃。")]),_._v(" "),t("p",[_._v("  接下来，路由器会根据IP头部中的内容进行包的"),t("strong",[_._v("转发")]),_._v("操作。同样查询"),t("strong",[_._v("路由表")]),_._v("判断转发目标，将目标IP地址与路由表中每一条目的子网掩码进行与运算，找到与Destination相同的条目，如果该条目的网关是一个IP地址，则这个IP地址是下一次需要转发的目标地址，还"),t("strong",[_._v("未抵达终点")]),_._v("，还需路由器转发，此时还是需要"),t("strong",[_._v("ARP协议")]),_._v("获取网关的MAC地址作为接收方MAC地址，网络包输出端口作为发送者MAC地址。紧接着转化为电信号并通过端口发送出去。")]),_._v(" "),t("p",[_._v("  然后再由交换机转发到下一个路由器。")]),_._v(" "),t("h3",{attrs:{id:"数据包拆包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据包拆包"}},[_._v("#")]),_._v(" 数据包拆包")]),_._v(" "),t("ul",[t("li",[_._v("1、一个请求最终是广播到目标服务器所在的子网中的所有机器。")]),_._v(" "),t("li",[_._v("2、这些机器都会将先扒开数据包的MAC头部，查看是否是发送给自己数据包，符合就收包，不符合就丢弃。")]),_._v(" "),t("li",[_._v("3、接着继续扒开数据包的IP头，发现IP地址符合，根据IP头中协议项，知道上层是TCP协议。")]),_._v(" "),t("li",[_._v("4、接着继续扒开数据包的TCP头，里面有序列号，看看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个ACK，如果不是就丢弃。TCP头部里面还有端口号，HTTP的服务器正在监听这个端口号。")]),_._v(" "),t("li",[_._v("5、服务器知道是HTTP进程想要这个数据包，于是将包发给HTTP进程。")]),_._v(" "),t("li",[_._v("6、服务器的HTTP进程发现请求是要访问一个页面，于是就把这个网页封装在HTTP响应报文里。")]),_._v(" "),t("li",[_._v("7、HTTP响应报文也需要一层层封装数据包TCP、IP、MAC头部，不过源地址是服务器IP地址，目标地址是客户端IP地址。")]),_._v(" "),t("li",[_._v("8、从网卡出去，交由路由器转发到另一个路由器，跳啊跳最后跳到了客户端的路由器，最后接收请求。")])]),_._v(" "),t("h3",{attrs:{id:"解析数据包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解析数据包"}},[_._v("#")]),_._v(" 解析数据包")])])}),[],!1,null,null,null);v.default=r.exports}}]);