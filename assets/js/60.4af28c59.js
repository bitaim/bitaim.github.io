(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{259:function(t,v,a){"use strict";a.r(v);var _=a(0),s=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),a("p",[t._v("java  -Dcom.bitaim.cn=我的天  -jar  as-1.0-SNAPSHOT.jar")]),t._v(" "),a("h2",{attrs:{id:"解决方案分析方法论-swot"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案分析方法论-swot"}},[t._v("#")]),t._v(" 解决方案分析方法论 SWOT")]),t._v(" "),a("p",[t._v("  （1）S（strengths）是优势。")]),t._v(" "),a("p",[t._v("  （2）W（weaknesses）是劣势。")]),t._v(" "),a("p",[t._v("  （3）O（opportunities）是机会。")]),t._v(" "),a("p",[t._v("  （4）T（threats）是威胁。")]),t._v(" "),a("p",[t._v("  比如消息中间件RabbitMQ和RocketMQ队列选择对比。")]),t._v(" "),a("p",[t._v("  比如RabbitMQ基于AMQP，实现了跨语言，比如生产者使用Java，消费者使用php，python等。阅读过源码的人过少，基于Erlang语言开发，二次修改不容易。多个容器平台拥抱RabbitMQ，易用性，扩展性强，前景好。未来可能有更强大的MQ产品出现或改动架构。")]),t._v(" "),a("h2",{attrs:{id:"团队管理smart"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#团队管理smart"}},[t._v("#")]),t._v(" 团队管理SMART")]),t._v(" "),a("p",[t._v("  （1）Specific，目标要具体。")]),t._v(" "),a("p",[t._v("  （2）Measurable，目标成果要可衡量。")]),t._v(" "),a("p",[t._v("  （3）Attainable，目标要可实现，避免过低、过高。")]),t._v(" "),a("p",[t._v("  （4）Relevant，与其他目标有一定的相关性")]),t._v(" "),a("p",[t._v("  （5）Time bound，目标必须有明确的期限")]),t._v(" "),a("h2",{attrs:{id:"devops"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#devops"}},[t._v("#")]),t._v(" DevOps")]),t._v(" "),a("p",[t._v("  开发、测试、运维人员的交集。开发人员完成需求的同时，也要考虑运维人员的维护成本。运维人员不单负责运维这块，也要去理解需求，参与项目需求评审，评价用户量、服务扩容等策略。以前是单一职责，现在是一专多能，考虑配合提效。")]),t._v(" "),a("p",[t._v("  核心是CI/CD，多环境-构建-打包-测试-上线-监控。快速迭代产品，每次代码的改动都触发校验，每刻都可以进行新版本的上线。")]),t._v(" "),a("h2",{attrs:{id:"开发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开发"}},[t._v("#")]),t._v(" 开发")]),t._v(" "),a("p",[t._v("  面向C端用户开发时，注重的是高并发和高可用。权限不校验。而在后台管理系统中，由于并发量较小，可以做权限的校验，比如用户、角色。")]),t._v(" "),a("h2",{attrs:{id:"n方库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#n方库"}},[t._v("#")]),t._v(" N方库")]),t._v(" "),a("p",[t._v("  一方库，本工程内部子项目模块依赖的库。")]),t._v(" "),a("p",[t._v("  二方库，公司内部发布到中央仓库，可供公司内部其他应用依赖的库。")]),t._v(" "),a("p",[t._v("  三方库，公司之外的开源库。")]),t._v(" "),a("h2",{attrs:{id:"redis集群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis集群"}},[t._v("#")]),t._v(" Redis集群")]),t._v(" "),a("p",[t._v("非核心集群、核心集群。高并发集群（比如首页、商品详情）、非高并发集群（订单列表）。")]),t._v(" "),a("p",[t._v("服务A、服务B、服务C可能共用一个非核心集群。服务D单独使用核心集群。如果某一个集群被拖垮了，可能会影响其他服务的正常运行，因此多个集群是很有必要的。")]),t._v(" "),a("p",[t._v("做到资源隔离、数据保护、提高性能。")]),t._v(" "),a("h2",{attrs:{id:"短信验证码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#短信验证码"}},[t._v("#")]),t._v(" 短信验证码")]),t._v(" "),a("p",[t._v("1、存储验证码到缓存。2、调用接口发送验证码。")]),t._v(" "),a("p",[t._v("非原子操作，存在不一致性的可能。增加额外的key-value存储，浪费空间。")]),t._v(" "),a("h2",{attrs:{id:"jwt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jwt"}},[t._v("#")]),t._v(" JWT")]),t._v(" "),a("p",[t._v("JWT过期后，用户无法直接感知，假如在用户操作页面期间，突然提示登录，则体验很不友好，所以有了token自动刷新的需求。但是自动刷新方案，基本离不开服务端状态存储，JWT的思想是去中心化，无状态话，所以有所违背。类似这样的业务，有阿里云首页，没有做token刷新令牌维护，但是符合对应的思想。")]),t._v(" "),a("p",[t._v("用户填写复杂表单的时候，突然失效了是很崩溃的。前端需要在cookie等中存以下草稿。避免丢失。")]),t._v(" "),a("p",[t._v("前端做刷新token的思想。登录时，生成两个token，accessToken和refreshToken，前端拿到refreshToken做混淆处理，让攻击者不知道那一个是用来刷新的token。")]),t._v(" "),a("p",[t._v("后端存储判断过期时间。优点前端改动小，只需要存储响应http头里面是否有新的令牌产生，有的话就重新存储。缺点，后端实现复杂，且泄露后容易存在一直保活状态，且前端会存在并发请求，当并发请求收到多个jwt token时，容易生成多个token混乱使用。")]),t._v(" "),a("p",[t._v("JWT令牌泄漏恶意使用解决方案。比如换了网络或者地域，对于阿里云或者淘宝，就需要重新登录。就是对应的token令牌，不知简单的算法加密，还包含了客户端属性、地址网络位置信息等。生成token时，加密的payload加入当前用户ip，判断ip是否相同。如果用户使用过程中ip变动频繁，则操作会经常提示重新登录，体验不友好。但要是不小心泄漏了账号，却很安全。")]),t._v(" "),a("h2",{attrs:{id:"越权攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#越权攻击"}},[t._v("#")]),t._v(" 越权攻击")]),t._v(" "),a("p",[t._v("很多接口 我们都是直接操作主键修改、删除，如果其他用户拿到了我们的接口，填写任意主键，就可以修改其他用户的信息，是不安全的。")]),t._v(" "),a("p",[t._v("越权攻击是Web应用程序中一种常见的漏洞，由于其存在范围广、危害大，被列为Web应用十大安全隐患的第二名。指应用在检查授权时存在纰漏，使得攻击者在获得低权限用户账户后，利用一些方式绕过权限检查，访问或操作其他用户或者更大权限。产生原因是开发人员在对数据进行增删改时对客户端请求的数据过分相信而遗漏了权限的判定。")]),t._v(" "),a("p",[t._v("水平越权，攻击者尝试访问与他拥有相关权限的用户的资源。A用户直接操作到B用户的数据。建立用户和可操作资源的绑定关系。")]),t._v(" "),a("p",[t._v("垂直越权，一个低级别攻击者尝试访问高级别用户的资源。例如普通管理员登录，拼接浏览器地址，直接访问高级管理员的页面。基于RBAC防范垂直越权。")]),t._v(" "),a("p",[t._v("对于c端更容易出现的水平越权问题。")]),t._v(" "),a("h2",{attrs:{id:"超卖超领问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#超卖超领问题"}},[t._v("#")]),t._v(" 超卖超领问题")]),t._v(" "),a("p",[t._v("对于有数量限制的类目，比如商品库存、优惠卷数量。如果仅仅通过数据库去判断，很容易出现超卖和超领的问题。在一些到达阈值的时候，很容易出现多个客户端领取的情况，那样多个客户端拿到的剩余数量为1时，可能会扣减成负数的情况"),a("code",[t._v("update coupon set count = count - 1 where cid = 1")]),t._v("。")]),t._v(" "),a("p",[t._v("nacos启动命令")]),t._v(" "),a("h2",{attrs:{id:"订单系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#订单系统"}},[t._v("#")]),t._v(" 订单系统")]),t._v(" "),a("p",[t._v("库存服务扣减库存前保存一个task任务，记录扣减的商品、数量还有关联的订单id（扣减和保存任务在同一个事务里）。库存任务表和优惠卷任务表都有一个核心字段"),a("code",[t._v("lock_state")]),t._v("锁定状态，LOCK完成（未支付），FINISH完成（已支付），CANCEL取消（订单不存在、超时或者关闭）。如果订单不存在则释放库存和优惠卷，如果订单已支付则忽略并标记成功。")]),t._v(" "),a("p",[t._v("创建订单的同时发送10分钟的延迟消息，用于超时未支付关单。发送12分钟的库存延迟消息，用于对于已关闭的订单的库存和优惠卷释放。")]),t._v(" "),a("p",[t._v("延迟消息需要确保发送成功，加入同一个本地事务，通过定时任务去发送延迟消息。")]),t._v(" "),a("p",[t._v("关单服务，收到延迟消息，需要判断一下订单是否支付，如果是LOCK未支付状态（正常情况下用户在第三方平台支付，平台会回调我们的接口，我们可以用来更新状态为FINISH，但如果是第三方推送失败呢），因此需要向第三方支付查询订单状态，如果是未支付状态，则关闭订单。")]),t._v(" "),a("p",[t._v("订单号和流水号的区别，是1对多的关系。比如一个订单有多个支付方式，也就是对应多个流水号。")]),t._v(" "),a("p",[t._v("用户的优惠卷有三个状态，NEW新的，EXPIRE过期的，USED以使用的。")]),t._v(" "),a("h2",{attrs:{id:"rabbitmq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq"}},[t._v("#")]),t._v(" RabbitMQ")]),t._v(" "),a("p",[t._v("一个交换机可以绑定多个队列，首先将消息发送到普通队列（没有消费者），普通队列中的消息过期后进入死信队列，这一逻辑构成了延迟队列。")])])}),[],!1,null,null,null);v.default=s.exports}}]);