(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{220:function(v,_,e){"use strict";e.r(_);var t=e(0),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"并发编程概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发编程概念"}},[v._v("#")]),v._v(" 并发编程概念")]),v._v(" "),e("p",[v._v("  并发编程或者说如何写出线程安全的代码，是非常考验程序员的功底的。")]),v._v(" "),e("p",[v._v("  并发编程有三座大山，"),e("strong",[v._v("原子性")]),v._v("、"),e("strong",[v._v("可见性")]),v._v("、"),e("strong",[v._v("有序性")]),v._v("。")]),v._v(" "),e("h2",{attrs:{id:"原子性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原子性"}},[v._v("#")]),v._v(" 原子性")]),v._v(" "),e("p",[v._v("  原子性问题的根本原因是"),e("strong",[v._v("线程切换")]),v._v("。处理器在执行机器指令时，可以在任意指令后发生线程切换，破坏了程序执行的原子性。")]),v._v(" "),e("p",[v._v("  通过加互斥锁的方式就可以保证程序的原子性，比如"),e("strong",[v._v("synchronized关键字")]),v._v("、"),e("strong",[v._v("ReentrantLock可重入锁")]),v._v("。")]),v._v(" "),e("h2",{attrs:{id:"可见性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可见性"}},[v._v("#")]),v._v(" 可见性")]),v._v(" "),e("p",[v._v("  可见性问题的根本原子是处理器的"),e("strong",[v._v("高速缓存")]),v._v("和为了提升处理器执行性能的一些策略，比如MESI协议、写缓冲器、无效队列等。")]),v._v(" "),e("p",[v._v("  当程序修改共享变量时，处理器执行的结果会写入高速缓存，通过异步的方式同步到主内存。所以其他线程不能及时感知到共享变量的变化。")]),v._v(" "),e("p",[v._v("  通过加互斥锁的方式或者更加轻量级的volatile关键字就可以保证程序的可见性。在写入一个变量后，强制刷回主内存。在读取一个变量前，先失效高速缓存，强制从主内存中读取。")]),v._v(" "),e("h2",{attrs:{id:"有序性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有序性"}},[v._v("#")]),v._v(" 有序性")]),v._v(" "),e("p",[v._v("  有序性问题的根本原因是"),e("strong",[v._v("指令重排序")]),v._v("。指令重排序的方式是多种多样的，为了提升指令的性能和并发度。")]),v._v(" "),e("p",[v._v("  指令重排序分为两类，一类是"),e("strong",[v._v("编译器的指令重排序")]),v._v("，另一类是"),e("strong",[v._v("CPU的指令重排序")]),v._v("（又细分为两种，指令级重排序，内存系统重排序）。")]),v._v(" "),e("p",[v._v("  重排序的目的是提升程序性能，但无论如何重排序都要保证程序最终运行结果不变，最常见的就是不会对存在依赖关系的指令进行重排序。这也是"),e("code",[v._v("as if serial（近似有序）")]),v._v("规则的要求，这种规则保证了程序在单线程的情况下结果正确，但在并发编程情况下是有问题的。")]),v._v(" "),e("p",[v._v("  上段提到的编译器不是将Java文件编译成Class字节码文件的过程，而是指JVM将字节码文件编译成机器指令过程。众所周知，Java是一门解释型和编译型的语言，通常情况下，JVM字节码默认是解释执行的，但是随着程序运行的时间越长，"),e("strong",[v._v("越来越多的热点代码会被JVM感知到进而被直接编译成机器指令以提高程序性能")]),v._v("。")]),v._v(" "),e("p",[v._v("  编译器的指令重排序和CPU的指令重排序的方式是各种各样的，无法举例子。而内存系统的重排序，也就是高速缓存和主内存短暂的数据不一致情况。")]),v._v(" "),e("p",[v._v("  通过加轻量级的volatile关键字就可以保证程序的有序性，在程序执行时通过内存屏障来禁止指令重排序保证有序性。")]),v._v(" "),e("h2",{attrs:{id:"happens-before"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#happens-before"}},[v._v("#")]),v._v(" Happens-Before")]),v._v(" "),e("p",[v._v("  Java程序遵守"),e("strong",[v._v("Happens-Before原则")]),v._v("。在大部分情况下，我们的程序是没有问题的。在涉及并发编程时，我们可以基于该原则来校验程序是否存在线程安全（可见性和有序性）问题。")]),v._v(" "),e("p",[v._v("  Happens-Before原则要表达的含义是前一个操作的结果对后一个操作是可见性的，不论是否发生在同一个线程里。")]),v._v(" "),e("p",[v._v("  规则一："),e("strong",[v._v("程序的顺序性规则")]),v._v("。指在一个线程内，按照程序顺序，前面的操作 "),e("code",[v._v("Happens-Before")]),v._v(" 于后续的任意操作。")]),v._v(" "),e("p",[v._v("  规则二："),e("strong",[v._v("volatile变量规则")]),v._v("。指对一个volatile变量的写操作 "),e("code",[v._v("Happens-Before")]),v._v(" 于后续对这个volatile变量的读操作。")]),v._v(" "),e("p",[v._v("  规则三："),e("strong",[v._v("传递性规则")]),v._v("。指如果 A操作 "),e("code",[v._v("Happens-Before")]),v._v(" B操作，且 B操作 "),e("code",[v._v("Happens-Before")]),v._v(" C操作，那么 A操作 "),e("code",[v._v("Happens-Before")]),v._v(" C操作。")]),v._v(" "),e("p",[v._v("  规则四："),e("strong",[v._v("管程中的锁规则")]),v._v("。指管程中的解锁操作 "),e("code",[v._v("Happens-Before")]),v._v(" 于后续的加锁操作。")]),v._v(" "),e("p",[v._v("  规则五："),e("strong",[v._v("线程启动规则")]),v._v("。子线程可以看到主线程启动子线程之前的所有操作。")]),v._v(" "),e("p",[v._v("  规则六："),e("strong",[v._v("线程终止规则")]),v._v("。主线程等待子线程完成（join），主线程可以看到子线程的所有操作。")]),v._v(" "),e("p",[v._v("  规则七："),e("strong",[v._v("线程中断规则")]),v._v("。对线程调用"),e("code",[v._v("interrupt()")]),v._v("方法 "),e("code",[v._v("Happends-Before")]),v._v(" 线程检测到中断的操作。")]),v._v(" "),e("p",[v._v("  规则八："),e("strong",[v._v("对象规则")]),v._v("。一个对象的初始化完成 "),e("code",[v._v("Happens-Before")]),v._v(" 一个对象的"),e("code",[v._v("finalize")]),v._v("方法。")])])}),[],!1,null,null,null);_.default=s.exports}}]);