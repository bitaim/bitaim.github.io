(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{208:function(v,_,e){"use strict";e.r(_);var o=e(0),n=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"垃圾回收器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器"}},[v._v("#")]),v._v(" 垃圾回收器")]),v._v(" "),e("p",[v._v("  当触发GC时，会有垃圾回收线程去清理垃圾。垃圾回收线程就会启动一个垃圾回收器，使用特定的算法来进行垃圾回收。")]),v._v(" "),e("p",[v._v("  在进行垃圾回收时，系统会停止工作，停止Java中所有的工作线程，禁止新对象的分配，然后让垃圾回收线程专心致志地进行垃圾回收工作。这也就是所谓地"),e("strong",[v._v("STW问题")]),v._v("。")]),v._v(" "),e("p",[v._v("  对于Serial和Serial Old垃圾回收器，分别用来收集新生代和老年代的垃圾，这两个垃圾回收器的特点是都是"),e("strong",[v._v("单线程回收垃圾")]),v._v("，所以回收效率比较差，一般不会使用这两种垃圾回收器。")]),v._v(" "),e("p",[v._v("  生产环境垃圾回收器标配组合，新生代使用"),e("strong",[v._v("ParNew垃圾回收器")]),v._v("，老年代使用"),e("strong",[v._v("CMS垃圾回收器")]),v._v("，这两个垃圾回收器的特点是针对服务器一般都是多核CPU进行优化，实现"),e("strong",[v._v("多线程并发控制")]),v._v("，大幅度提升回收性能，缩短回收时间。")]),v._v(" "),e("h3",{attrs:{id:"新生代垃圾回收器-parnew"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#新生代垃圾回收器-parnew"}},[v._v("#")]),v._v(" 新生代垃圾回收器 ParNew")]),v._v(" "),e("p",[v._v("  在G1垃圾回收器出现前，线上系统通常都是使用ParNew垃圾回收器作为新生代的垃圾回收器。即使现在出现了G1，其实很多线上系统还是使用的是ParNew。"),e("strong",[v._v("新生代ParNew主打多线程垃圾回收机制")]),v._v("，采用的算法是复制算法。")]),v._v(" "),e("p",[v._v("  运行在服务器上的系统，都可以充分利用服务器多核CPU的优势。如果是4核CPU却仅仅使用单线程进行垃圾回收，岂不是浪费CPU资源。ParNew的垃圾回收线程数量默认是与CPU的核数是一样的，就可以成倍的提升回收性能。")]),v._v(" "),e("p",[v._v("  可以通过参数"),e("code",[v._v("-XX:+UseParNewGC")]),v._v("来指定使用ParNew垃圾回收器。也可以通过参数"),e("code",[v._v("-XX:ParallelGCThreads")]),v._v("来指定垃圾回收线程的数量，该参数默认与CPU核数相当，一般不用调整。")]),v._v(" "),e("h3",{attrs:{id:"老年代垃圾回收器-cms"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#老年代垃圾回收器-cms"}},[v._v("#")]),v._v(" 老年代垃圾回收器 CMS")]),v._v(" "),e("p",[v._v("  老年代一般选择CMS作为其垃圾回收器，采用的是"),e("strong",[v._v("标记清理算法")]),v._v("。CMS的特点是"),e("strong",[v._v("垃圾回收线程和系统工作线程尽量同时执行的模式来处理")]),v._v("，避免系统长时间卡顿。CMS的垃圾回收过程主要有四个阶段：")]),v._v(" "),e("p",[e("strong",[v._v("  （1）初始标记阶段")]),v._v("，标记出所有GC Roots（方法的局部变量和类的静态变量是GC Roots）"),e("strong",[v._v("直接引用")]),v._v("的对象，标记存活对象。该阶段会让系统的工作线程全部停止，进入STW状态。但影响不大，因为该阶段很快。")]),v._v(" "),e("p",[e("strong",[v._v("  （2）并发标记阶段")]),v._v("，垃圾回收线程和工作线程同时进行。在该过程中，会产生新的对象或者失去引用的新的垃圾对象。垃圾回收线程会对老年代所有的对象进行GC Roots追踪，是最耗时的阶段。虽然耗时，但是是与工作线程同时进行的，因此对系统的影响较小。")]),v._v(" "),e("p",[e("strong",[v._v("  （3）重新标记阶段")]),v._v("，该阶段要停止系统程序，进入STW状态。对第二阶段出现的存活对象和垃圾对象进行标记，所以运行速度很快。")]),v._v(" "),e("p",[e("strong",[v._v("  （4）并发清理阶段")]),v._v("，让系统程序随意运行，然后清理掉之前标记为垃圾的对象即可。也是很耗时的，但不影响系统程序的运行。")]),v._v(" "),e("p",[v._v("  在并发标记和并发清理阶段，垃圾回收线程是需要消耗一些CPU资源的。所以CMS默认启动的垃圾回收线程的数量是（ CPU核数 + 3 ） / 4 = 垃圾回收线程的数量。")]),v._v(" "),e("p",[v._v("  并发清理阶段，只是会回收之前标记好的垃圾对象。但是在这个阶段，可能会有新的对象进入老年代并成为垃圾对象（浮动对象），这些垃圾对象只有在下一次GC时才会被回收。所以为了保证在CMS垃圾回收期间，还有一定的内存让一些对象可以进入老年代，一般会"),e("strong",[v._v("预留一些空间")]),v._v("。")]),v._v(" "),e("p",[v._v("  CMS垃圾回收的触发时机，其中有一个是当老年代内存占用达到一定比例时，就会自动执行GC。可以通过参数"),e("code",[v._v("-XX:CMSInitiatingOccupancyFaction")]),v._v("调整，默认值是92%。如果CMS垃圾回收期间，要进入老年代的对象大于了可用内存，那么就会发生"),e("code",[v._v("Concurrent Mode Failure")]),v._v("，也就是并发垃圾回收失败了。此时就会自动使用Serial Old垃圾回收器替代CMS，强行进入STW状态，重新进行长时间的GC Roots追踪，标记出全部垃圾对象，不允许新的对象产生。"),e("strong",[v._v("在生产实践中，需要调整参数"),e("code",[v._v("-XX:CMSInitiatingOccupancyFaction")]),v._v("的比例，避免并发垃圾回收失败的问题")]),v._v("。")]),v._v(" "),e("p",[v._v("  标记清理算法造成的内存碎片问题，CMS有一个参数"),e("code",[v._v("-XX:+UseCMSCompactAtFullCollection")]),v._v("是默认打开的。在Full GC之后要再次进入STW状态，停止工作线程，对内存碎片进行整理，将存活对象移动到一起，"),e("strong",[v._v("避免内存碎片导致更加频繁的Full GC")]),v._v("。还有一个参数"),e("code",[v._v("-XX:CMSFullGCsBeforeCompaction")]),v._v("，默认是0，代表每次执行完Full GC都要进行内存碎片的整理。")]),v._v(" "),e("p",[e("strong",[v._v("1、为什么老年代垃圾回收这么慢")]),v._v("？")]),v._v(" "),e("p",[v._v("  新生代存活对象是很少的，从GC Roots追踪存活对象速度是很快的，然后将存活对象放入Survivor区，一次性回收Eden区和Survivor区即可。")]),v._v(" "),e("p",[v._v("  而老年代存活对象是很多的，在并发标记阶段，追踪这些存活对象这个过程就会很慢。最后还需要进行内存碎片的整理。万一再发生"),e("code",[v._v("Concurrent Mode Failure")]),v._v("，还需要重新进行一遍垃圾回收那就更慢了。")]),v._v(" "),e("h3",{attrs:{id:"g1垃圾回收器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#g1垃圾回收器"}},[v._v("#")]),v._v(" G1垃圾回收器")]),v._v(" "),e("p",[v._v("  G1垃圾回收器对新生代和老年代进行了统一的垃圾回收。统一使用复制算法来进行垃圾回收，并采用更加优秀的设计以及算法，最终目的都是为了去解决STW问题。")]),v._v(" "),e("p",[v._v("  G1垃圾回收器最大的特点是"),e("strong",[v._v("将堆内存划分为多个大小相等的Region")]),v._v("。还有一个特点是可以"),e("strong",[v._v("设置一个垃圾回收的预期停顿时间")]),v._v("。")]),v._v(" "),e("p",[v._v("  之前对堆内存的内存合理分配以及优化参数，都是为了尽可能地减少Minor GC和Full GC，尽量减少GC带来的系统停顿。而现在可以通过参数配置，让G1垃圾回收器来帮助我们达到这个目的。")]),v._v(" "),e("p",[e("strong",[v._v("1、如何做到停顿时间可控呢")]),v._v("？")]),v._v(" "),e("p",[v._v("  G1让我们来设定垃圾回收对系统的影响，通过将内存拆分为大量的Region，以及追踪每个Region中可以回收的对象大小和预估时间。最后在进行垃圾回收时，尽量把垃圾回收对系统造成的影响控制在指定的时间内，同时在有限的时间内回收尽可能多的垃圾对象。")]),v._v(" "),e("p",[e("strong",[v._v("2、新生代和老年代概念")])]),v._v(" "),e("p",[v._v("  某些Region是新生代（某些Regin是Eden区，某些Region是Survivor区），某些Region是老年代，只不过是逻辑上的概念。")]),v._v(" "),e("p",[v._v("  Region中的内存分配不是一成不变的，而是根据需要会被划分到不同的分代模型。在G1对应的内存模型中，Region随时会属于新生代也会属性老年代。所以没有所谓新生代分配多少内存，老年代分配多少内存，这些内存区域都是由G1自动控制的。")]),v._v(" "),e("p",[e("strong",[v._v("3、Region")])]),v._v(" "),e("p",[v._v("  通过参数"),e("code",[v._v("-Xms")]),v._v("和"),e("code",[v._v("-Xmx")]),v._v("来设置堆内存大小，并通过参数"),e("code",[v._v("-XX:+UseG1GC")]),v._v("指定G1垃圾回收器。"),e("strong",[v._v("每个Region的大小是堆内存/2048")]),v._v("，JVM最多可以有2048个Region。也可以通过参数"),e("code",[v._v("-XX:G1HeapRegionSize")]),v._v("来设置。")]),v._v(" "),e("p",[v._v("  假设堆内存为4096MB，那么每个Region的内存大小是2MB。刚开始时，新生代默认在堆内存中占比5%，大概200MB左右的内存，100个Region。可以通过参数"),e("code",[v._v("-XX:G1NewSizePercent")]),v._v("来设置，保持默认即可。在系统运行中，JVM会不断的给新生代增加更多的Region，但是新生代最大占比不会超过60%，可以通过参数"),e("code",[v._v("-XX:G1MaxNewSizePercent")]),v._v("来设置。一旦Region进行了垃圾回收，此时新生代的数量还会减少，这些都是动态变化的。")]),v._v(" "),e("p",[e("strong",[v._v("4、新生代")])]),v._v(" "),e("p",[v._v("  当新生代内存占用达到了设定的60%时，就会触发Minor GC。G1垃圾回收器会使用"),e("strong",[v._v("复制算法")]),v._v("来进行垃圾回收，并且进入STW状态。然后把Eden区对应的Region中的存活对象复制到Survivor区的Region中。接着收到掉这些Region区域。")]),v._v(" "),e("p",[v._v("  G1可以通过参数"),e("code",[v._v("-XX:MaxGCPauseMills")]),v._v("来指定GC停顿时间，默认值是200ms。")]),v._v(" "),e("p",[e("strong",[v._v("5、老年代")])]),v._v(" "),e("p",[v._v("  新生代对象进入老年代的条件与之前相同，唯一的区别是大对象不再进入老年代，在G1的内存模型下，有专门的Region负责存放大对象，大对象的判定规则是超过了一个Region中的50%。而且一个大对象如果太大，可能会横跨多个Region来存放。在新生代和老年代在进行垃圾回收时，会顺带着大对象Region一起回收。")]),v._v(" "),e("p",[v._v("  当老年代占据了堆内存45%（"),e("code",[v._v("-XX:InitiatingHeapOccupancyPercent")]),v._v("）的时候，此时就会尝试触发"),e("strong",[v._v("新生代和老年代的混合回收阶段")]),v._v("。此时垃圾回收不仅回收老年代，同时还会回收新生代和大对象。因为指定了GC停顿时间，所以会从新生代、 老年代、大对象对应的Region中挑选一些回收价值大的区域，保证在指定的时间内回收尽可能多的垃圾对象。")]),v._v(" "),e("p",[v._v("  （1）初始标记。停止系统的运行，然后对各个线程栈内存中的局部变量代表的GC Roots，以及方法区中的类静态变量代表的GC Roots，进行扫描，标记出直接引用的那些对象。")]),v._v(" "),e("p",[v._v("  （2）并发标记。允许系统的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象（初始标记阶段，没有标记类中的实例变量）。")]),v._v(" "),e("p",[v._v("  （3）最终标记。停止系统的运行，但是会根据并发标记阶段记录的对象修改，最终标记一下哪些是存活对象，哪些是垃圾对象。")]),v._v(" "),e("p",[v._v("  （4）混合回收。这个阶段会计算每个Region（新生代、老年代、大对象）中的存活对象数量，存活对象的占比，执行垃圾回收的预期性能和效率。接着会停止系统程序，在保证停顿时间的前提下选择部分Region进行回收。该阶段是执行多次混合回收的，因为每次回收一部分而已，次数是由"),e("code",[v._v("-XX:G1MixedGCCountTarget")]),v._v("参数决定的，默认值是8。让系统在多次回收的间隙中运行一下。空闲出来的Region一旦达到5%的时候，就会停止混合回收，由参数"),e("code",[v._v("-XX:G1HeapWastePercent")]),v._v("决定，默认5%。")]),v._v(" "),e("p",[v._v("  G1整体无论是年轻代还是老年代都是基于复制算法来进行回收的，不会出现内存碎片的问题。只有存活对象低于85%的Region才会参与垃圾回收，是由参数"),e("code",[v._v("-XX:G1MixedGCLiveThresholdPercent")]),v._v("决定的，默认是85%。因为存活对象过高的话，复制成本是很高的。")]),v._v(" "),e("p",[e("strong",[v._v("6、混合回收失败")])]),v._v(" "),e("p",[v._v("  在进行混合回收时，无论是新生代还是老年代都是通过复制算法进行回收的，都要把各个Region中的存活对象复制到其他的Region里去。一旦在拷贝的过程中，发现没有空闲的Region可以承载自己的存活对象，就会触发一次失败。")]),v._v(" "),e("p",[v._v("  一旦失败，立刻就会停止程序。然后采用单线程进行标记、清理、压缩整理，空闲出来一批Region，这个过程是极慢的。")])])}),[],!1,null,null,null);_.default=n.exports}}]);