(window.webpackJsonp=window.webpackJsonp||[]).push([[198],{480:function(s,e,t){"use strict";t.r(e);var a=t(14),i=Object(a.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"redis集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis集群"}},[s._v("#")]),s._v(" Redis集群")]),s._v(" "),t("p",[s._v("  Redis集群有很多种方式，比如主从、集群模式。要根据业务类型来选择合适的集群模式。")]),s._v(" "),t("h2",{attrs:{id:"预约功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预约功能"}},[s._v("#")]),s._v(" 预约功能")]),s._v(" "),t("p",[s._v("  对于一些热门商品，比如茅台、球鞋等。每次抢购活动都会有大量的用户进行预约，那么预约功能该如何实现呢？")]),s._v(" "),t("p",[s._v("  数据库是承受不住这么大的压力的。因此我们采用Redis集群来抗高并发写入的预约请求，将用户预约写入Redis的缓存中。")]),s._v(" "),t("p",[s._v("  每个用户的id都是唯一的，那么指针用户预约的读写功能都是非常容易最大限度的利用到Redis集群中的各个机器的资源，做到较为平均的分配。对于Redis的集群架构，主从只是备份，并没有提供读写分离。")]),s._v(" "),t("p",[s._v("  对于Key，我们可以设计为用hash存储。比如预约:<用户id>，hash中的key记录各种秒杀活动的id。因为一个用户可能会参与多个秒杀活动，这样设计既完成了预约功能，又可以查询用户的预约列表。而某次活动的预约信息，在该场次抢购开始时就会被删除。")]),s._v(" "),t("h2",{attrs:{id:"秒杀活动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#秒杀活动"}},[s._v("#")]),s._v(" 秒杀活动")]),s._v(" "),t("p",[s._v("  预约机构->待抢购->抢购")]),s._v(" "),t("p",[s._v("  创建一次秒杀活动需要使用Redis的主从哨兵模式，用来抗大量的读请求。如果采用Redis集群模式，对于热门商品有单点问题。")]),s._v(" "),t("p",[s._v("  Redis集群具有高可用、可拓展性、分布式、容错、去中心化、自动故障转移等特性。还有一些缺点，数据通过异步复制，无法保证数据强一致性；集群环境搭建略微复杂。")]),s._v(" "),t("p",[s._v("  Redis集群中的Master节点总共有16384个slot插槽。官方推荐最小的Redis集群架构是三主三从，每个主节点最少配备一个从节点，可以是多个。")])])}),[],!1,null,null,null);e.default=i.exports}}]);