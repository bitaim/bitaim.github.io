(window.webpackJsonp=window.webpackJsonp||[]).push([[266],{550:function(v,_,t){"use strict";t.r(_);var o=t(14),a=Object(o.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"xxljob"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#xxljob"}},[v._v("#")]),v._v(" xxljob")]),v._v(" "),t("p",[v._v("  job逻辑要考虑幂等设计。")]),v._v(" "),t("p",[v._v("  job逻辑尽可能轻量级，不要太重，导致执行逻辑很久（如果确实逻辑比较复杂，可以分拆job或者从代码层面优化，例如：分批并行处理、减少单次处理数据）")]),v._v(" "),t("p",[v._v("  构建数据到缓存类似的job，尽可能选择在晚上12点以后，尽量不要白天进行，白天流量很大，重建缓存容易引起接口抖动。")]),v._v(" "),t("p",[v._v("  对于定时执行的job，设计执行时间的时候，要慎重考虑线上整个job的执行时间，根据这个时间配置cron表达式，不要拍脑袋随意设置，不然本次job没执行完，\n下一次job执行的时候容易错过。")]),v._v(" "),t("p",[v._v("  对于大表数据（百万、千万、亿级），可以利用xxljob的分片处理能力，并行刷数据，提高处理速度。")]),v._v(" "),t("h2",{attrs:{id:"接口设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口设计"}},[v._v("#")]),v._v(" 接口设计")]),v._v(" "),t("p",[v._v("  高并发接口必须在测试环境压测，清楚的知道接口支持的QPS，另外根据压测报告给出的优化建议，及时调整线上的配置、代码优化。")]),v._v(" "),t("p",[v._v("  提供给C端的接口，要清楚曝光位置，然后根据接口可能预计调用的流量，压测的接口最大的QPS，决定是否扩容、是否需要限流及兜底逻辑、是否熔断。")]),v._v(" "),t("p",[v._v("  程序中涉及的异常信息，及时配置错误监控告警，遇事做到心中有数。")]),v._v(" "),t("p",[v._v("  对于业务关键位置，及时打印info级别的业务追踪日志，如果是高并发接口，要做好开关，能秒级关闭，因为打印日志也特别消耗性能。")]),v._v(" "),t("p",[v._v("  程序设计方面，高并发接口，尽可能使用缓存，能异步就异步（一般用mq，不要用多线程异步），尽可能使用无锁设计防止线程lock CPU冲高，批量写库")]),v._v(" "),t("p",[v._v("  接口前置逻辑提前，尽早过滤掉不合规逻辑，缩短接口整个调用链路时长，提升接口整体吞吐量。")]),v._v(" "),t("p",[v._v("  接口要考虑无状态设计，幂等设计（考虑分布式锁唯一key），安全设计（接口方法签名，是否接第三方防刷服务判断是否黑产用户）")]),v._v(" "),t("p",[v._v("  对第三方服务做到0信任，考虑降级、熔断，与业务确认好兜底逻辑处理。")]),v._v(" "),t("p",[v._v("  工具类尽可能使用apache、google出品的，一些github小众的开源框架很多在高并发场景下有bug和性能瓶颈。")]),v._v(" "),t("p",[v._v("  接口的时间复杂度，部分逻辑在设计的时候尽可能保证是O(1)。例如调用第三方接口，for循环调用的，是否可以提到循环外，传多个id批量调用一次，时间复杂度从O(n)降为O(1)")])])}),[],!1,null,null,null);_.default=a.exports}}]);