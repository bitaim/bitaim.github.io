(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{368:function(_,v,t){"use strict";t.r(v);var e=t(0),s=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"网络io模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络io模型"}},[_._v("#")]),_._v(" 网络IO模型")]),_._v(" "),t("p",[_._v("  Linux中常用的4种网络IO模式。")]),_._v(" "),t("ul",[t("li",[_._v("阻塞I/O（blocking IO）")]),_._v(" "),t("li",[_._v("非阻塞I/O（nonblocking IO）")]),_._v(" "),t("li",[_._v("I/O多路复用（IO multiplexing）")]),_._v(" "),t("li",[_._v("异步I/O（asynchronous IO）")])]),_._v(" "),t("h3",{attrs:{id:"阻塞i-o"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#阻塞i-o"}},[_._v("#")]),_._v(" 阻塞I/O")]),_._v(" "),t("p",[_._v("  在同步阻塞IO模式种，程序的IO系统调用开始，直到系统调用返回。这段时间内，进程（Linux下线程同样也是进程）都是阻塞的，也就是"),t("strong",[_._v("当前线程被阻塞")]),_._v("。阻塞分为两个阶段：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("等待数据就绪")]),_._v("。对于网络IO而言，是等待远端的数据到达。对于磁盘IO而言，是等待磁盘数据从磁盘读取到内核缓冲区。")]),_._v(" "),t("li",[t("strong",[_._v("复制的复制")]),_._v("。等待内核缓冲区的数据复制到用户空间的缓冲区。")])]),_._v(" "),t("p",[_._v("  直到成功返回后，进程才开始处理用户空间的缓冲区数据。")]),_._v(" "),t("p",[t("strong",[_._v("特点")])]),_._v(" "),t("p",[_._v("  优点。开发简单。在阻塞等待数据期间，用户线程挂起，不占用CPU资源。")]),_._v(" "),t("p",[_._v("  缺点。需要为每一个连接分配一个线程，在高并发应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常大。")]),_._v(" "),t("h3",{attrs:{id:"非阻塞i-o"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞i-o"}},[_._v("#")]),_._v(" 非阻塞I/O")]),_._v(" "),t("p",[_._v("  在内核缓冲区没有数据的情况下，系统调用会"),t("strong",[_._v("立即返回")]),_._v("调用失败的结果，"),t("strong",[_._v("线程不会被阻塞")]),_._v("。")]),_._v(" "),t("p",[_._v("  用户线程需要不断的发起IO系统调用，看看内核数据是否准备好了没有。")]),_._v(" "),t("p",[_._v("  内核数据准备好了以后，用户线程发起系统调用，此时用户线程被阻塞，开始将内核缓冲区的数据复制到用户缓冲区，然后系统调用返回。")]),_._v(" "),t("p",[_._v("  用户线程开始执行业务逻辑。")]),_._v(" "),t("p",[t("strong",[_._v("低。")])]),_._v(" "),t("p",[t("strong",[_._v("特点")])]),_._v(" "),t("p",[_._v("  优点。每次发起的IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。")]),_._v(" "),t("p",[_._v("  缺点。用户进程使用非阻塞I/O需要轮询方式进行系统调用以询问内核是否准备好数据，效率低下。")]),_._v(" "),t("h3",{attrs:{id:"i-o多路复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i-o多路复用"}},[_._v("#")]),_._v(" I/O多路复用")]),_._v(" "),t("p",[_._v("  在IO多路复用种，引入了三种新的系统调用"),t("strong",[_._v("select、poll、epoll")]),_._v("。可以做到"),t("strong",[_._v("一个线程同时监视多个文件描述符，由内核来判断是否数据到来")]),_._v("，一旦某个文件描述符就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序。")]),_._v(" "),t("p",[_._v("  应用程序根据就绪的状态，进行相应的IO系统调用。")]),_._v(" "),t("p",[_._v("  使用这些系统调用，就可以用一个线程同时监视成百上千的Socket连接，一旦有Socket网络连接有IO就绪的状态，就返回对应的可执行的读写操作。")]),_._v(" "),t("p",[t("strong",[_._v("特点")])]),_._v(" "),t("p",[_._v("  优点。使用一个线程就可以同时轮询成百上千的连接。系统不必要创建和维护大量的线程，大大减小的系统的开销。")]),_._v(" "),t("p",[_._v("  缺点。select/epoll调用都是阻塞时的，属于同步IO。都需要在读写事件就绪后，由系统调用本身负责读写。也就是这个读写过程是阻塞的。")]),_._v(" "),t("p",[t("strong",[_._v("1、select")])]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("#include <sys/select.h>\n\n// 最关注的读描述符集 其他传null\nint select(int nfds, fd_set *readfds, fd_set *writefds,\n           fd_set *exceptfds, struct timeval *timeout);\n\nvoid FD_CLR(int fd, fd_set *set);\nint  FD_ISSET(int fd, fd_set *set);\nvoid FD_SET(int fd, fd_set *set);\nvoid FD_ZERO(fd_set *set);\n\nint pselect(int nfds, fd_set *readfds, fd_set *writefds,\n            fd_set *exceptfds, const struct timespec *timeout,\n            const sigset_t *sigmask);\n")])])]),t("p",[_._v("  其中"),t("code",[_._v("fd_set")]),_._v("是一个bitmap，由内核参数来控制大小，最大长度为1024，代表可以同时监听1024个文件描述符。虽然可以调整，但性能可能会更差。")]),_._v(" "),t("p",[_._v("  由于bitmap是下从下标0开始的，如果我们需要监听3、4、8这三个文件描述符，就需要传入"),t("code",[_._v("nfds=9")]),_._v("（最大文件描述符+1），这样才可以监听。")]),_._v(" "),t("ol",[t("li",[_._v("发起select系统调用时，会把"),t("code",[_._v("fd_set")]),_._v("从用户空间复制到内核空间，应用程序进入阻塞状态。")]),_._v(" "),t("li",[_._v("内核根据"),t("code",[_._v("fd_set")]),_._v("得到需要处理器的文件描述符，如果相应的准备好了数据，就会将"),t("code",[_._v("fd_set")]),_._v("进行置为。随后系统调用返回。")]),_._v(" "),t("li",[_._v("进程被唤醒后，拿到内核处理过的"),t("code",[_._v("fd_set")]),_._v("，然后通过"),t("code",[_._v("FD_ISSET")]),_._v("判断是否被置位，然后就可以执行相应的后续IO操作了。但这里需要遍历所有的文件描述符，因为不知道哪一个被置位。")]),_._v(" "),t("li",[_._v("下一次发起select系统调用时，又要重新准备"),t("code",[_._v("fd_set")]),_._v("，因此已经被置位过，没有办法再次使用了。")])]),_._v(" "),t("p",[t("strong",[_._v("2、poll")])]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("#include <poll.h>\n\n// pollfd *fds 数组\n// nfds 数量\n// 超时时间\nint poll(struct pollfd *fds, nfds_t nfds, int timeout);\n            \nstruct pollfd {\n  int   fd;         /* 待检测的文件描述符 */\n  short events;     /* 监测的事件 */\n  short revents;    /* 监测到数据时，给该字段置位 */\n};\n")])])]),t("ol",[t("li",[_._v("发起poll系统调用，会把pollfd从用户空间拷贝到内核空间，应用程序进入阻塞状态。")]),_._v(" "),t("li",[_._v("内核根据文件描述符的监听事件，给"),t("code",[_._v("pollfd")]),_._v("的"),t("code",[_._v("revents")]),_._v("进行置位。")]),_._v(" "),t("li",[_._v("进程被唤醒，拿到内核处理后的pollfd，判断对应事件是否被置位，然后执行后续操作。")])]),_._v(" "),t("p",[_._v("  优点。")]),_._v(" "),t("p",[_._v("  与select类似，但使用数组取代了bitmap，没有了文件描述符1024的限制。")]),_._v(" "),t("p",[_._v("  引入了"),t("code",[_._v("pollfd")]),_._v("结构体，只需要重置"),t("code",[_._v("revents")]),_._v("字段，就可以做到复用"),t("code",[_._v("pollfd")]),_._v("。")]),_._v(" "),t("p",[_._v("  缺点。")]),_._v(" "),t("p",[_._v("  每次调用poll都需要拷贝新的poll_fd到内核空间，存在用户态到内核态的切换。")]),_._v(" "),t("p",[_._v("  拿到pollfd之后，需要全部遍历，才知道哪些文件描述符被置位。")]),_._v(" "),t("p",[t("strong",[_._v("3、epoll")])]),_._v(" "),t("p",[_._v("  epoll是Linux特有的I/O复用函数，在实现上与"),t("code",[_._v("select")]),_._v("、"),t("code",[_._v("poll")]),_._v("有很大的差异。epoll把用户关心的文件描述符放在内核的一个事件表里，而无须像"),t("code",[_._v("select")]),_._v("、"),t("code",[_._v("poll")]),_._v("那样每次调用都需要传入文件描述符或集合集。但epoll需要一个额外的文件描述符，来唯一标识内核中的一个事件表。")]),_._v(" "),t("p",[_._v("  epoll的事件表是一颗红黑树。")]),_._v(" "),t("ol",[t("li",[_._v("使用"),t("code",[_._v("int epoll_create(int size)")]),_._v("创建一个事件表，并返回一个文件描述符。")]),_._v(" "),t("li",[_._v("使用"),t("code",[_._v("epoll_ctl")]),_._v("向事件表中添加、修改、删除需要监听的文件描述符及事件。")]),_._v(" "),t("li",[_._v("使用"),t("code",[_._v("epoll_wait")]),_._v("系统调用等待内核的监听结果，进程开始阻塞。内核会将准备好的文件描述符放入就绪队列中。然后返回该就绪队列。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);