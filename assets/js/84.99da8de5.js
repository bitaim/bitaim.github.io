(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{284:function(_,v,e){"use strict";e.r(v);var t=e(0),o=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"阿里规约"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#阿里规约"}},[_._v("#")]),_._v(" 阿里规约")]),_._v(" "),e("h2",{attrs:{id:"建表规约"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#建表规约"}},[_._v("#")]),_._v(" 建表规约")]),_._v(" "),e("p",[_._v("  （1）表达是否概念的字段，必须使用"),e("code",[_._v("is_xxx")]),_._v("的命名方式，数据类型是"),e("code",[_._v("unsigned tinyint")]),_._v("。比如，表达逻辑删除的字段名"),e("code",[_._v("is_deleted")]),_._v("，1表示是，0表示否。")]),_._v(" "),e("p",[_._v("  （1.1）如果字段是非负数（大于等于0），必须是"),e("code",[_._v("unsigned")]),_._v("的。")]),_._v(" "),e("p",[_._v("  （1.2）POJO类中的任何布尔类型的变量，"),e("strong",[_._v("都不要加is前缀")]),_._v("，在ResultMap中设置映射关系。")]),_._v(" "),e("p",[_._v("  （2）MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写的。"),e("strong",[_._v("数据库名、表名、字段名必须使用小写字母或数字")]),_._v("，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因此无法进行预发布，所以字段名称要慎重考虑。")]),_._v(" "),e("p",[_._v("  （3）表名不使用复数名词。对应的DO类名也是单数形式。")]),_._v(" "),e("p",[_._v("  （4）主键索引名为"),e("code",[_._v("pk_字段名")]),_._v("，唯一索引名为"),e("code",[_._v("uk_字段名")]),_._v("，普通索引名则为"),e("code",[_._v("idx_字段名")]),_._v("。")]),_._v(" "),e("p",[_._v("  （5）小数类型为"),e("code",[_._v("decimal")]),_._v("，禁止使用"),e("code",[_._v("float")]),_._v("和"),e("code",[_._v("double")]),_._v("。在存储时，float和double存在精度损失的问题，很可能在比较值的时候，出现不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数并分开存储。")]),_._v(" "),e("p",[_._v("  （6）如果存储的字符串长度几乎相等，使用"),e("code",[_._v("char")]),_._v("定长字符串类型。")]),_._v(" "),e("p",[_._v("  （7）"),e("code",[_._v("varchar")]),_._v("是可变长字段，不预先分配存储空间，长度不要超过5000。如果存储长度大于此值，定义字段类型为"),e("code",[_._v("text")]),_._v("，独立出来一张表。用主键来对应，避免影响其他字段索引效率。")]),_._v(" "),e("p",[_._v("  （8）表必备三字段，主键（bigint unsigned），创建时间（datetime）、修改时间（datetime）。")]),_._v(" "),e("p",[_._v("  （9）字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循，不是频繁修改的字段，不是唯一索引的字段，不是varchar超长字段，更不能是text字段。")]),_._v(" "),e("p",[_._v("  （10）单表行数超过500万行或者单表容量超过2GB，才推荐分库分表。")]),_._v(" "),e("p",[_._v("  （11）合适的字段存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。无符号值可以避免误存负数，且扩大了表示范围。比如"),e("code",[_._v("tinyint")]),_._v("表示"),e("code",[_._v("[-128,127]")]),_._v("。而"),e("code",[_._v("tinyint unsigned")]),_._v("，表示 "),e("code",[_._v("[0,255]")]),_._v("。")]),_._v(" "),e("h2",{attrs:{id:"索引规约"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引规约"}},[_._v("#")]),_._v(" 索引规约")]),_._v(" "),e("p",[_._v("  （1）业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。")]),_._v(" "),e("p",[_._v("  （1.1）不要以为唯一索引影响了insert速度，这个速度损耗可以忽略不计，但提高查询速度是明显的。")]),_._v(" "),e("p",[_._v("  （1.2）即使在应用层做了非常完善的校验规则，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。")]),_._v(" "),e("p",[_._v("  （2）超过三个表禁止join。需要join的字段，数据类型保持绝对一致。多表关联查询时，保证被关联的字段需要有索引。")]),_._v(" "),e("p",[_._v("  （3）在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，"),e("strong",[_._v("根据实际文本区分度决定索引长度")]),_._v("。可以使用 "),e("code",[_._v("count(distinct left(列名, 索引长度))/count(*)")]),_._v("的区分度来确定。")]),_._v(" "),e("p",[_._v("  （4）页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。")]),_._v(" "),e("p",[_._v("  （5）如果有"),e("code",[_._v("order by")]),_._v("的场景，请注意索引的有序性。避免出现"),e("code",[_._v("file_sort")]),_._v("的情况，影响查询性能。")]),_._v(" "),e("p",[_._v("  （5.1）比如索引"),e("code",[_._v("a_b_c")]),_._v("，"),e("code",[_._v("where a = ? and b = ? order by c")]),_._v("。")]),_._v(" "),e("p",[_._v("  （5.2）索引如果存在范围查询，那么索引的有序性无法利用。")]),_._v(" "),e("p",[_._v("  （6）使用覆盖索引。查看执行计划时，extra列会出现"),e("code",[_._v("using index")]),_._v(" 。")]),_._v(" "),e("p",[_._v("  （7）MySQL在深度分页时，性能会变差。MySQL并不是跳过多少行，而是取 offset + N 行，然后放弃 offset 行，返回 N 行。当offset非常大的时候，效率就非常低下。")]),_._v(" "),e("p",[_._v("  （8）SQL性能优化的目标，至少达到range级别，要求是ref级别，如果可以是consts最好。")]),_._v(" "),e("p",[_._v("  （9）防止因字段类型不同造成的隐式转换，导致索引失效。")]),_._v(" "),e("p",[_._v("  （10）建组合索引时，区分度最高的在最左边。如果最左列几乎接近于唯一，那么只需要建立idx_a即可。如果存在非等号和等号混合判断条件时，在建索引时，把等号条件的列前置。即使非等号字段区分度很大也不行。")]),_._v(" "),e("p",[_._v("  （11）创建索引的误区。")]),_._v(" "),e("p",[_._v("  （11.1）索引宁缺毋滥。认为一个查询就需要建立一个索引。")]),_._v(" "),e("p",[_._v("  （11.2）吝啬索引的创建。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。")]),_._v(" "),e("p",[_._v("  （11.3）抵制唯一索引。认为唯一索引一律需要在应用层通过先查后插的方式解决。")]),_._v(" "),e("h2",{attrs:{id:"sql语句"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sql语句"}},[_._v("#")]),_._v(" SQL语句")]),_._v(" "),e("p",[_._v("  （1）不要使用"),e("code",[_._v("COUNT(列名)")]),_._v("和"),e("code",[_._v("COUNT(常量)")]),_._v("来替代"),e("code",[_._v("COUNT(*)")]),_._v("。"),e("code",[_._v("COUNT(distinct 列名)")]),_._v("，计算该列除NULL之外的不重复行数。\n"),e("code",[_._v("count(distinct col1,col2)")]),_._v("，如果其中一列为null，那么即使另一列有值，也返回为0。")]),_._v(" "),e("p",[_._v("  （2）使用 "),e("code",[_._v("is null")]),_._v(" 来判断是否为Null值。"),e("code",[_._v("SELECT IFNULL(SUM(col1),0) FROM table")])]),_._v(" "),e("p",[_._v("  （3）"),e("code",[_._v("in操作")]),_._v("能避免则避免，若避免不了，需要评估in后面集合的数量，控制在1000个之内。")]),_._v(" "),e("h2",{attrs:{id:"orm映射"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#orm映射"}},[_._v("#")]),_._v(" ORM映射")]),_._v(" "),e("p",[_._v("  （1）在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。增加查询分析器解析成本，增减字段容易与ResultMap配置不一致，无用字段增加网络消耗。")]),_._v(" "),e("p",[_._v("  （2）POJO类的布尔属性不能加"),e("code",[_._v("is")]),_._v("，而数据库字段必须加"),e("code",[_._v("is_")]),_._v("，要求在ResultMap中进行字段和属性之间的映射。")]),_._v(" "),e("p",[_._v("  （3）不要使用resultType当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义ResultMap，反过来，每一个表也必然有一个ResultMap与之对应。使字段与DO类解耦，方便维护。")]),_._v(" "),e("p",[_._v("  （4）不要使用"),e("code",[_._v("${}")]),_._v("防止SQL注入。")]),_._v(" "),e("p",[_._v("  （5）不要写一个大而全的数据更新接口。更新字段时，不要更新无改动的字段。一是易出错，二是效率低，三是增加binlog存储。")]),_._v(" "),e("p",[_._v("  （6）"),e("code",[_._v("@Transactional")]),_._v(" 事务注解不要滥用，事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。")])])}),[],!1,null,null,null);v.default=o.exports}}]);