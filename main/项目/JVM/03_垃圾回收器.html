<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>垃圾回收器 | 山  海</title>
    <meta name="description" content="">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    
    <link rel="preload" href="/assets/css/0.styles.032ce348.css" as="style"><link rel="preload" href="/assets/js/app.daf90e44.js" as="script"><link rel="preload" href="/assets/js/2.5c2f89f7.js" as="script"><link rel="preload" href="/assets/js/11.2c1e7667.js" as="script"><link rel="prefetch" href="/assets/js/10.060e2bf0.js"><link rel="prefetch" href="/assets/js/12.e4112fb1.js"><link rel="prefetch" href="/assets/js/13.c48f2af3.js"><link rel="prefetch" href="/assets/js/14.4c74936a.js"><link rel="prefetch" href="/assets/js/15.dde0f892.js"><link rel="prefetch" href="/assets/js/16.04fdeec3.js"><link rel="prefetch" href="/assets/js/17.50a51165.js"><link rel="prefetch" href="/assets/js/18.8ae9a823.js"><link rel="prefetch" href="/assets/js/19.ccac1f50.js"><link rel="prefetch" href="/assets/js/20.dc3b4da0.js"><link rel="prefetch" href="/assets/js/21.537f2917.js"><link rel="prefetch" href="/assets/js/22.fa0e5570.js"><link rel="prefetch" href="/assets/js/23.dbc6b9de.js"><link rel="prefetch" href="/assets/js/24.86da2a97.js"><link rel="prefetch" href="/assets/js/25.8db6665f.js"><link rel="prefetch" href="/assets/js/26.7ff0ce90.js"><link rel="prefetch" href="/assets/js/27.498e5d1f.js"><link rel="prefetch" href="/assets/js/28.c7a49776.js"><link rel="prefetch" href="/assets/js/29.3f057de0.js"><link rel="prefetch" href="/assets/js/3.b7af9e84.js"><link rel="prefetch" href="/assets/js/30.15140778.js"><link rel="prefetch" href="/assets/js/31.e91d7705.js"><link rel="prefetch" href="/assets/js/32.e8b9f267.js"><link rel="prefetch" href="/assets/js/33.9d40e450.js"><link rel="prefetch" href="/assets/js/34.7c76fee5.js"><link rel="prefetch" href="/assets/js/35.893bc59e.js"><link rel="prefetch" href="/assets/js/36.13ad14c2.js"><link rel="prefetch" href="/assets/js/37.7b7d3440.js"><link rel="prefetch" href="/assets/js/38.93ac778e.js"><link rel="prefetch" href="/assets/js/39.10b0f4fe.js"><link rel="prefetch" href="/assets/js/4.11dd4e91.js"><link rel="prefetch" href="/assets/js/40.464abc1f.js"><link rel="prefetch" href="/assets/js/41.29e1fdca.js"><link rel="prefetch" href="/assets/js/42.415177f1.js"><link rel="prefetch" href="/assets/js/43.422cbd1e.js"><link rel="prefetch" href="/assets/js/44.f9780e88.js"><link rel="prefetch" href="/assets/js/45.2731c44f.js"><link rel="prefetch" href="/assets/js/46.eb287d68.js"><link rel="prefetch" href="/assets/js/47.a3668e5f.js"><link rel="prefetch" href="/assets/js/48.892840a4.js"><link rel="prefetch" href="/assets/js/49.b7d6cbaf.js"><link rel="prefetch" href="/assets/js/5.e02fc35f.js"><link rel="prefetch" href="/assets/js/50.06cadfd1.js"><link rel="prefetch" href="/assets/js/51.40d31a4d.js"><link rel="prefetch" href="/assets/js/52.33a7f0cc.js"><link rel="prefetch" href="/assets/js/53.13a99099.js"><link rel="prefetch" href="/assets/js/54.d6a76531.js"><link rel="prefetch" href="/assets/js/55.d31ae64c.js"><link rel="prefetch" href="/assets/js/56.805fbd61.js"><link rel="prefetch" href="/assets/js/57.b457ef1b.js"><link rel="prefetch" href="/assets/js/58.372ee965.js"><link rel="prefetch" href="/assets/js/59.3ef115d3.js"><link rel="prefetch" href="/assets/js/6.41be9e56.js"><link rel="prefetch" href="/assets/js/60.87fd023f.js"><link rel="prefetch" href="/assets/js/61.86290fe0.js"><link rel="prefetch" href="/assets/js/62.5f84a20b.js"><link rel="prefetch" href="/assets/js/63.7baf0019.js"><link rel="prefetch" href="/assets/js/7.96ae93e8.js"><link rel="prefetch" href="/assets/js/8.30d5150e.js"><link rel="prefetch" href="/assets/js/9.04db00b8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.032ce348.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">山  海</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/main/项目/" class="nav-link">导航栏</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/main/项目/" class="nav-link">导航栏</a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="垃圾回收器"><a href="#垃圾回收器" class="header-anchor">#</a> 垃圾回收器</h1> <p>  当触发GC时，会有垃圾回收线程去清理垃圾。垃圾回收线程就会启动一个垃圾回收器，使用特定的算法来进行垃圾回收。</p> <p>  在进行垃圾回收时，系统会停止工作，停止Java中所有的工作线程，禁止新对象的分配，然后让垃圾回收线程专心致志地进行垃圾回收工作。这也就是所谓地<strong>STW问题</strong>。</p> <p>  对于Serial和Serial Old垃圾回收器，分别用来收集新生代和老年代的垃圾，这两个垃圾回收器的特点是都是<strong>单线程回收垃圾</strong>，所以回收效率比较差，一般不会使用这两种垃圾回收器。</p> <p>  生产环境垃圾回收器标配组合，新生代使用<strong>ParNew垃圾回收器</strong>，老年代使用<strong>CMS垃圾回收器</strong>，这两个垃圾回收器的特点是针对服务器一般都是多核CPU进行优化，实现<strong>多线程并发控制</strong>，大幅度提升回收性能，缩短回收时间。</p> <h3 id="新生代垃圾回收器-parnew"><a href="#新生代垃圾回收器-parnew" class="header-anchor">#</a> 新生代垃圾回收器 ParNew</h3> <p>  在G1垃圾回收器出现前，线上系统通常都是使用ParNew垃圾回收器作为新生代的垃圾回收器。即使现在出现了G1，其实很多线上系统还是使用的是ParNew。<strong>新生代ParNew主打多线程垃圾回收机制</strong>，采用的算法是复制算法。</p> <p>  运行在服务器上的系统，都可以充分利用服务器多核CPU的优势。如果是4核CPU却仅仅使用单线程进行垃圾回收，岂不是浪费CPU资源。ParNew的垃圾回收线程数量默认是与CPU的核数是一样的，就可以成倍的提升回收性能。</p> <p>  可以通过参数<code>-XX:+UseParNewGC</code>来指定使用ParNew垃圾回收器。也可以通过参数<code>-XX:ParallelGCThreads</code>来指定垃圾回收线程的数量，该参数默认与CPU核数相当，一般不用调整。</p> <h3 id="老年代垃圾回收器-cms"><a href="#老年代垃圾回收器-cms" class="header-anchor">#</a> 老年代垃圾回收器 CMS</h3> <p>  老年代一般选择CMS作为其垃圾回收器，采用的是<strong>标记清理算法</strong>。CMS的特点是<strong>垃圾回收线程和系统工作线程尽量同时执行的模式来处理</strong>，避免系统长时间卡顿。CMS的垃圾回收过程主要有四个阶段：</p> <p><strong>  （1）初始标记阶段</strong>，标记出所有GC Roots（方法的局部变量和类的静态变量是GC Roots）<strong>直接引用</strong>的对象，标记存活对象。该阶段会让系统的工作线程全部停止，进入STW状态。但影响不大，因为该阶段很快。</p> <p><strong>  （2）并发标记阶段</strong>，垃圾回收线程和工作线程同时进行。在该过程中，会产生新的对象或者失去引用的新的垃圾对象。垃圾回收线程会对老年代所有的对象进行GC Roots追踪，是最耗时的阶段。虽然耗时，但是是与工作线程同时进行的，因此对系统的影响较小。</p> <p><strong>  （3）重新标记阶段</strong>，该阶段要停止系统程序，进入STW状态。对第二阶段出现的存活对象和垃圾对象进行标记，所以运行速度很快。</p> <p><strong>  （4）并发清理阶段</strong>，让系统程序随意运行，然后清理掉之前标记为垃圾的对象即可。也是很耗时的，但不影响系统程序的运行。</p> <p>  在并发标记和并发清理阶段，垃圾回收线程是需要消耗一些CPU资源的。所以CMS默认启动的垃圾回收线程的数量是（ CPU核数 + 3 ） / 4 = 垃圾回收线程的数量。</p> <p>  并发清理阶段，只是会回收之前标记好的垃圾对象。但是在这个阶段，可能会有新的对象进入老年代并成为垃圾对象（浮动对象），这些垃圾对象只有在下一次GC时才会被回收。所以为了保证在CMS垃圾回收期间，还有一定的内存让一些对象可以进入老年代，一般会<strong>预留一些空间</strong>。</p> <p>  CMS垃圾回收的触发时机，其中有一个是当老年代内存占用达到一定比例时，就会自动执行GC。可以通过参数<code>-XX:CMSInitiatingOccupancyFaction</code>调整，默认值是92%。如果CMS垃圾回收期间，要进入老年代的对象大于了可用内存，那么就会发生<code>Concurrent Mode Failure</code>，也就是并发垃圾回收失败了。此时就会自动使用Serial Old垃圾回收器替代CMS，强行进入STW状态，重新进行长时间的GC Roots追踪，标记出全部垃圾对象，不允许新的对象产生。<strong>在生产实践中，需要调整参数<code>-XX:CMSInitiatingOccupancyFaction</code>的比例，避免并发垃圾回收失败的问题</strong>。</p> <p>  标记清理算法造成的内存碎片问题，CMS有一个参数<code>-XX:+UseCMSCompactAtFullCollection</code>是默认打开的。在Full GC之后要再次进入STW状态，停止工作线程，对内存碎片进行整理，将存活对象移动到一起，<strong>避免内存碎片导致更加频繁的Full GC</strong>。还有一个参数<code>-XX:CMSFullGCsBeforeCompaction</code>，默认是0，代表每次执行完Full GC都要进行内存碎片的整理。</p> <p><strong>1、为什么老年代垃圾回收这么慢</strong>？</p> <p>  新生代存活对象是很少的，从GC Roots追踪存活对象速度是很快的，然后将存活对象放入Survivor区，一次性回收Eden区和Survivor区即可。</p> <p>  而老年代存活对象是很多的，在并发标记阶段，追踪这些存活对象这个过程就会很慢。最后还需要进行内存碎片的整理。万一再发生<code>Concurrent Mode Failure</code>，还需要重新进行一遍垃圾回收那就更慢了。</p> <h3 id="g1垃圾回收器"><a href="#g1垃圾回收器" class="header-anchor">#</a> G1垃圾回收器</h3> <p>  G1垃圾回收器对新生代和老年代进行了统一的垃圾回收。统一使用复制算法来进行垃圾回收，并采用更加优秀的设计以及算法，最终目的都是为了去解决STW问题。</p> <p>  G1垃圾回收器最大的特点是<strong>将堆内存划分为多个大小相等的Region</strong>。还有一个特点是可以<strong>设置一个垃圾回收的预期停顿时间</strong>。</p> <p>  之前对堆内存的内存合理分配以及优化参数，都是为了尽可能地减少Minor GC和Full GC，尽量减少GC带来的系统停顿。而现在可以通过参数配置，让G1垃圾回收器来帮助我们达到这个目的。</p> <p><strong>1、如何做到停顿时间可控呢</strong>？</p> <p>  G1让我们来设定垃圾回收对系统的影响，通过将内存拆分为大量的Region，以及追踪每个Region中可以回收的对象大小和预估时间。最后在进行垃圾回收时，尽量把垃圾回收对系统造成的影响控制在指定的时间内，同时在有限的时间内回收尽可能多的垃圾对象。</p> <p><strong>2、新生代和老年代概念</strong></p> <p>  某些Region是新生代（某些Regin是Eden区，某些Region是Survivor区），某些Region是老年代，只不过是逻辑上的概念。</p> <p>  Region中的内存分配不是一成不变的，而是根据需要会被划分到不同的分代模型。在G1对应的内存模型中，Region随时会属于新生代也会属性老年代。所以没有所谓新生代分配多少内存，老年代分配多少内存，这些内存区域都是由G1自动控制的。</p> <p><strong>3、Region</strong></p> <p>  通过参数<code>-Xms</code>和<code>-Xmx</code>来设置堆内存大小，并通过参数<code>-XX:+UseG1GC</code>指定G1垃圾回收器。<strong>每个Region的大小是堆内存/2048</strong>，JVM最多可以有2048个Region。也可以通过参数<code>-XX:G1HeapRegionSize</code>来设置。</p> <p>  假设堆内存为4096MB，那么每个Region的内存大小是2MB。刚开始时，新生代默认在堆内存中占比5%，大概200MB左右的内存，100个Region。可以通过参数<code>-XX:G1NewSizePercent</code>来设置，保持默认即可。在系统运行中，JVM会不断的给新生代增加更多的Region，但是新生代最大占比不会超过60%，可以通过参数<code>-XX:G1MaxNewSizePercent</code>来设置。一旦Region进行了垃圾回收，此时新生代的数量还会减少，这些都是动态变化的。</p> <p><strong>4、新生代</strong></p> <p>  当新生代内存占用达到了设定的60%时，就会触发Minor GC。G1垃圾回收器会使用<strong>复制算法</strong>来进行垃圾回收，并且进入STW状态。然后把Eden区对应的Region中的存活对象复制到Survivor区的Region中。接着收到掉这些Region区域。</p> <p>  G1可以通过参数<code>-XX:MaxGCPauseMills</code>来指定GC停顿时间，默认值是200ms。</p> <p><strong>5、老年代</strong></p> <p>  新生代对象进入老年代的条件与之前相同，唯一的区别是大对象不再进入老年代，在G1的内存模型下，有专门的Region负责存放大对象，大对象的判定规则是超过了一个Region中的50%。而且一个大对象如果太大，可能会横跨多个Region来存放。在新生代和老年代在进行垃圾回收时，会顺带着大对象Region一起回收。</p> <p>  当老年代占据了堆内存45%（<code>-XX:InitiatingHeapOccupancyPercent</code>）的时候，此时就会尝试触发<strong>新生代和老年代的混合回收阶段</strong>。此时垃圾回收不仅回收老年代，同时还会回收新生代和大对象。因为指定了GC停顿时间，所以会从新生代、 老年代、大对象对应的Region中挑选一些回收价值大的区域，保证在指定的时间内回收尽可能多的垃圾对象。</p> <p>  （1）初始标记。停止系统的运行，然后对各个线程栈内存中的局部变量代表的GC Roots，以及方法区中的类静态变量代表的GC Roots，进行扫描，标记出直接引用的那些对象。</p> <p>  （2）并发标记。允许系统的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象（初始标记阶段，没有标记类中的实例变量）。</p> <p>  （3）最终标记。停止系统的运行，但是会根据并发标记阶段记录的对象修改，最终标记一下哪些是存活对象，哪些是垃圾对象。</p> <p>  （4）混合回收。这个阶段会计算每个Region（新生代、老年代、大对象）中的存活对象数量，存活对象的占比，执行垃圾回收的预期性能和效率。接着会停止系统程序，在保证停顿时间的前提下选择部分Region进行回收。该阶段是执行多次混合回收的，因为每次回收一部分而已，次数是由<code>-XX:G1MixedGCCountTarget</code>参数决定的，默认值是8。让系统在多次回收的间隙中运行一下。空闲出来的Region一旦达到5%的时候，就会停止混合回收，由参数<code>-XX:G1HeapWastePercent</code>决定，默认5%。</p> <p>  G1整体无论是年轻代还是老年代都是基于复制算法来进行回收的，不会出现内存碎片的问题。只有存活对象低于85%的Region才会参与垃圾回收，是由参数<code>-XX:G1MixedGCLiveThresholdPercent</code>决定的，默认是85%。因为存活对象过高的话，复制成本是很高的。</p> <p><strong>6、混合回收失败</strong></p> <p>  在进行混合回收时，无论是新生代还是老年代都是通过复制算法进行回收的，都要把各个Region中的存活对象复制到其他的Region里去。一旦在拷贝的过程中，发现没有空闲的Region可以承载自己的存活对象，就会触发一次失败。</p> <p>  一旦失败，立刻就会停止程序。然后采用单线程进行标记、清理、压缩整理，空闲出来一批Region，这个过程是极慢的。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.daf90e44.js" defer></script><script src="/assets/js/2.5c2f89f7.js" defer></script><script src="/assets/js/11.2c1e7667.js" defer></script>
  </body>
</html>
